{"version":3,"sources":["../src/types.ts","../src/state.ts","../src/util.ts","../src/network.ts","../src/agent.ts","../src/model.ts","../src/adapters/index.ts","../src/adapters/anthropic.ts","../src/tool.ts","../src/adapters/openai.ts","../src/adapters/azure-openai.ts","../src/adapters/gemini.ts","../src/adapters/grok.ts","../src/streaming.ts","../src/history.ts"],"sourcesContent":["import xxh from \"xxhashjs\";\n\nexport type Message = TextMessage | ToolCallMessage | ToolResultMessage;\n\n/**\n * UserMessage represents a rich message object from a client that can contain\n * not just the message content but also client-side state, timestamps, and\n * optional system prompts for a single turn.\n */\nexport interface UserMessage {\n  /** The canonical, client-generated unique identifier for the message. */\n  id: string;\n\n  /** The text content of the user's message. */\n  content: string;\n\n  /** The role is always 'user' to accurately represent the source. */\n  role: \"user\";\n\n  /** Optional, client-provided state snapshot to be persisted. */\n  state?: Record<string, unknown>;\n\n  /** Optional, client-provided timestamp for optimistic UI ordering. */\n  clientTimestamp?: Date | string;\n\n  /** Optional, one-time system prompt to prepend for this specific turn. */\n  systemPrompt?: string;\n}\n\n/**\n * TextMessage represents plain text messages in the chat history, eg. the user's prompt or\n * an assistant's reply.\n */\nexport interface TextMessage {\n  type: \"text\";\n  role: \"system\" | \"user\" | \"assistant\";\n  content: string | Array<TextContent>;\n  // Anthropic:\n  // stop_reason: \"end_turn\" | \"max_tokens\" | \"stop_sequence\" | \"tool_use\" | null;\n  // OpenAI:\n  // finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | 'function_call' | null;\n  stop_reason?: \"tool\" | \"stop\";\n}\n\n/**\n * ToolCallMessage represents a message for a tool call.\n */\nexport interface ToolCallMessage {\n  type: \"tool_call\";\n  role: \"user\" | \"assistant\";\n  tools: ToolMessage[];\n  stop_reason: \"tool\";\n}\n\n/**\n * ToolResultMessage represents the output of a tool call.\n */\nexport interface ToolResultMessage {\n  type: \"tool_result\";\n  role: \"tool_result\";\n  // tool contains the tool call request for this result.\n  tool: ToolMessage;\n  content: unknown;\n  stop_reason: \"tool\";\n}\n\n// Message content.\n\nexport interface TextContent {\n  type: \"text\";\n  text: string;\n}\n\nexport interface ToolMessage {\n  type: \"tool\";\n  id: string;\n  name: string;\n  input: Record<string, unknown>;\n}\n\n/**\n * AgentResult represents a single iteration of an agent call in the router\n * loop.  This includes the input prompt, the resulting messages, and any\n * tool call results.\n *\n * This is used in several ways:\n *\n *   1. To track the results of a given agent, including output and tool results.\n *   2. To construct chat history for each agent call in a network loop.\n *   3. To track what was sent to a given agent at any time.\n *\n *\n * ## Chat history and agent inputs in Networks.\n *\n * Networks call agents in a loop.  Each iteration of the loop adds to conversation\n * history.\n *\n * We construct the agent input by:\n *\n *   1. Taking the system prompt from an agent\n *   2. Adding the user request as a message\n *   3. If provided, adding the agent's assistant message.\n *\n * These two or three messages are ALWAYS the start of an agent's request:\n * [system, input, ?assistant].\n *\n * We then iterate through the state's AgentResult objects, adding the output\n * and tool calls from each result to chat history.\n *\n */\nexport class AgentResult {\n  constructor(\n    /**\n     * agentName represents the name of the agent which created this result.\n     */\n    public agentName: string,\n\n    /**\n     * output represents the parsed output from the inference call.  This may be blank\n     * if the agent responds with tool calls only.\n     */\n    public output: Message[],\n\n    /**\n     * toolCalls represents output from any tools called by the agent.\n     */\n    public toolCalls: ToolResultMessage[],\n\n    /**\n     * createdAt represents when this message was created.\n     */\n    public createdAt: Date,\n\n    /**\n     * prompt represents the input instructions - without any additional history\n     * - as created by the agent.  This includes the system prompt, the user input,\n     * and any initial agent assistant message.\n     *\n     * This is ONLY used for tracking and debugging purposes, and is entirely optional.\n     * It is not used to construct messages for future calls, and only serves to see\n     * what was sent to the agent in this specific request.\n     */\n    public prompt?: Message[],\n\n    /**\n     * history represents the history sent to the inference call, appended to the\n     * prompt to form a complete conversation log.\n     *\n     * This is ONLY used for tracking and debugging purposes, and is entirely optional.\n     * It is not used to construct messages for future calls, and only serves to see\n     * what was sent to the agent in this specific request.\n     */\n    public history?: Message[],\n\n    /**\n     * raw represents the raw API response from the call.  This is a JSON\n     * string, and the format depends on the agent's model.\n     */\n    public raw?: string,\n\n    /**\n     * id represents the unique identifier for this agent result.\n     * This is used for persistence and message identification.\n     */\n    public id?: string\n  ) {}\n\n  // checksum memoizes a checksum so that it doe snot have to be calculated many times.\n  #checksum?: string;\n\n  /**\n   * export returns all fields necessary to store the AgentResult for future use.\n   */\n  export() {\n    return {\n      agentName: this.agentName,\n      output: this.output,\n      toolCalls: this.toolCalls,\n      createdAt: this.createdAt,\n      checksum: this.checksum,\n    };\n  }\n\n  /**\n   * checksum is a unique ID for this result.\n   *\n   * It is generated by taking a checksum of the message output and the created at date.\n   * This allows you to dedupe items when saving conversation history.\n   */\n  get checksum(): string {\n    if (this.#checksum === undefined) {\n      const input =\n        JSON.stringify(this.output.concat(this.toolCalls)) +\n        this.createdAt.toString();\n      this.#checksum = xxh.h64(input, 0).toString();\n    }\n    return this.#checksum;\n  }\n}\n","import { type AgentResult, type Message } from \"./types\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type StateData = Record<string, any>;\n\n/**\n * createState creates new state for a given network.  You can add any\n * initial state data for routing, plus provide an object of previous\n * AgentResult objects or conversation history within Message.\n *\n * To store chat history, we strongly recommend serializing and storing\n * the list of AgentResult items from state after each network run.\n *\n * You can then load and pass those messages into this constructor to\n * create conversational memory.\n *\n * You can optionally pass a list of Message types in this constructor.\n * Any messages in this State will always be added after the system and\n * user prompt.\n */\nexport const createState = <T extends StateData>(\n  initialState?: T,\n  opts?: Omit<State.Constructor<T>, \"data\">\n): State<T> => {\n  return new State({ ...opts, data: initialState });\n};\n\n/**\n * State stores state (history) for a given network of agents.  The state\n * includes a stack of all AgentResult items and strongly-typed data\n * modified via tool calls.\n *\n * From this, the chat history can be reconstructed (and manipulated) for each\n * subsequent agentic call.\n */\nexport class State<T extends StateData> {\n  public data: T;\n  public threadId?: string;\n\n  private _data: T;\n\n  /**\n   * _results stores all agent results.  This is internal and is used to\n   * track each call made in the network loop.\n   */\n  private _results: AgentResult[];\n\n  /**\n   * _messages stores a linear history of ALL messages from the current\n   * network.  You can seed this with initial messages to create conversation\n   * history.\n   */\n  private _messages: Message[];\n\n  constructor({\n    data,\n    messages,\n    threadId,\n    results,\n  }: State.Constructor<T> = {}) {\n    this._results = results || [];\n    this._messages = messages || [];\n    this._data = data ? { ...data } : ({} as T);\n    this.threadId = threadId;\n\n    // Create a new proxy that allows us to intercept the setting of state.\n    //\n    // This will be used to add middleware hooks to record state\n    // before and after setting.\n    this.data = new Proxy(this._data, {\n      set: (target, prop: string | symbol, value) => {\n        if (typeof prop === \"string\" && prop in target) {\n          // Update the property\n          Reflect.set(target, prop, value);\n          return true;\n        }\n        return Reflect.set(target, prop, value);\n      },\n    });\n\n    // NOTE: KV is deprecated and should be fully typed.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.#_kv = new Map<string, any>(Object.entries(this._data));\n    this.kv = {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      set: (key: string, value: any) => {\n        this.#_kv.set(key, value);\n      },\n      get: (key: string) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return this.#_kv.get(key);\n      },\n      delete: (key: string) => {\n        return this.#_kv.delete(key);\n      },\n      has: (key: string) => {\n        return this.#_kv.has(key);\n      },\n      all: () => {\n        return Object.fromEntries(this.#_kv);\n      },\n    };\n  }\n\n  /**\n   * Results returns a new array containing all past inference results in the\n   * network. This array is safe to modify.\n   */\n  get results(): AgentResult[] {\n    return this._results.slice();\n  }\n\n  /**\n   * Replaces all results with the provided array\n   * used when loading initial results from history.get()\n   */\n  setResults(results: AgentResult[]) {\n    this._results = results;\n  }\n\n  /**\n   * Returns a slice of results from the given start index\n   * used when saving results to a database via history.appendResults()\n   */\n  getResultsFrom(startIndex: number): AgentResult[] {\n    return this._results.slice(startIndex);\n  }\n\n  /**\n   * Messages returns a new array containing all initial messages that were\n   * provided to the constructor. This array is safe to modify.\n   */\n  get messages(): Message[] {\n    return this._messages.slice();\n  }\n\n  /**\n   * formatHistory returns the memory used for agentic calls based off of prior\n   * agentic calls.\n   *\n   * This is used to format the current State as a conversation log when\n   * calling an individual agent.\n   *\n   */\n  formatHistory(formatter?: (r: AgentResult) => Message[]): Message[] {\n    if (!formatter) {\n      formatter = defaultResultFormatter;\n    }\n\n    // Always add any messages before any AgentResult items.  This allows\n    // you to preload any\n    return this._messages.concat(\n      this._results.map((result) => formatter(result)).flat()\n    );\n  }\n\n  /**\n   * appendResult appends a given result to the current state.  This\n   * is called by the network after each iteration.\n   */\n  appendResult(call: AgentResult) {\n    this._results.push(call);\n  }\n\n  /**\n   * clone allows you to safely clone the state.\n   */\n  clone() {\n    const state = new State<T>({\n      data: this.data,\n      threadId: this.threadId,\n      messages: this._messages.slice(),\n      results: this._results.slice(),\n    });\n    return state;\n  }\n\n  /**\n   * @deprecated Fully type state instead of using the KV.\n   */\n  public kv: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    set: <T = any>(key: string, value: T) => void;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    get: <T = any>(key: string) => T | undefined;\n    delete: (key: string) => boolean;\n    has: (key: string) => boolean;\n    all: () => Record<string, unknown>;\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #_kv: Map<string, any>;\n}\n\nexport namespace State {\n  export type Constructor<T extends StateData> = {\n    /**\n     * Data represents initial typed data\n     */\n    data?: T;\n\n    /**\n     * Results represents any previous AgentResult entries for\n     * conversation history and memory.\n     */\n    results?: AgentResult[];\n\n    /**\n     * Messages allows you to pas custom messages which will be appended\n     * after the system and user message to each agent.\n     */\n    messages?: Message[];\n\n    /**\n     * threadId is the unique identifier for a conversation thread.\n     */\n    threadId?: string;\n  };\n}\n\nconst defaultResultFormatter = (r: AgentResult): Message[] => {\n  return ([] as Message[]).concat(r.output).concat(r.toolCalls);\n};\n","import { type Inngest, type InngestFunction, isInngestFunction } from \"inngest\";\nimport { type AsyncContext, getAsyncCtx } from \"inngest/experimental\";\nimport { type ZodType, ZodObject } from \"zod\";\n\nexport type MaybePromise<T> = T | Promise<T>;\n\n/**\n * AnyZodType is a type alias for any Zod type.\n *\n * It specifically matches the typing used for the OpenAI JSON schema typings,\n * which do not use the standardized `z.ZodTypeAny` type.\n *\n * Not that using this type directly can break between any versions of Zod\n * (including minor and patch versions). It may be pertinent to maintain a\n * custom type which matches many versions in the future.\n */\nexport type AnyZodType = ZodType;\n\n/**\n * Given an unknown value, return a string representation of the error if it is\n * an error, otherwise return the stringified value.\n */\nexport const stringifyError = (e: unknown): string => {\n  if (e instanceof Error) {\n    return e.message;\n  }\n\n  return String(e);\n};\n\n/**\n * Attempts to retrieve the step tools from the async context.\n */\nexport const getStepTools = async (): Promise<\n  AsyncContext[\"ctx\"][\"step\"] | undefined\n> => {\n  // The shape of the experimental async context changed across versions.\n  // This is now stable, but we support both shapes here for compatibility.\n  const asyncCtx = await getAsyncCtx();\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n  const ctx = asyncCtx?.ctx || (asyncCtx as any)?.execution?.ctx;\n\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n  return ctx?.step;\n};\n\nexport const isInngestFn = (fn: unknown): fn is InngestFunction.Any => {\n  // Derivation of `InngestFunction` means it's definitely correct\n  if (isInngestFunction(fn)) {\n    return true;\n  }\n\n  // If it's not derived from `InngestFunction`, it could still be a function\n  // but from a different version of the library. Depending on your other deps\n  // this could be likely and multiple versions of the `inngest` package are\n  // installed at the same time. Thus, we check the generic shape here instead.\n  if (\n    typeof fn === \"object\" &&\n    fn !== null &&\n    \"createExecution\" in fn &&\n    typeof fn.createExecution === \"function\"\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\nexport const getInngestFnInput = (\n  fn: InngestFunction.Any\n): AnyZodType | undefined => {\n  const runtimeSchemas = (fn[\"client\"] as Inngest.Any)[\"schemas\"]?.[\n    \"runtimeSchemas\"\n  ];\n  if (!runtimeSchemas) {\n    return;\n  }\n\n  const schemasToAttempt = new Set<string>(\n    (fn[\"opts\"] as InngestFunction.Options).triggers?.reduce((acc, trigger) => {\n      if (trigger.event) {\n        return [...acc, trigger.event];\n      }\n\n      return acc;\n    }, [] as string[]) ?? []\n  );\n\n  if (!schemasToAttempt.size) {\n    return;\n  }\n\n  let schema: AnyZodType | undefined;\n\n  for (const eventSchema of schemasToAttempt) {\n    const runtimeSchema = runtimeSchemas[eventSchema];\n\n    // We only support Zod atm\n    if (\n      typeof runtimeSchema === \"object\" &&\n      runtimeSchema !== null &&\n      \"data\" in runtimeSchema &&\n      helpers.isZodObject(runtimeSchema.data)\n    ) {\n      if (schema) {\n        schema = schema.or(runtimeSchema.data);\n      } else {\n        schema = runtimeSchema.data;\n      }\n      continue;\n    }\n\n    // TODO It could also be a regular object with inidivudal fields, so\n    // validate that too\n  }\n\n  return schema;\n};\n\nconst helpers = {\n  isZodObject: (value: unknown): value is ZodObject => {\n    return value instanceof ZodObject;\n  },\n\n  isObject: (value: unknown): value is Record<string, unknown> => {\n    return typeof value === \"object\" && value !== null && !Array.isArray(value);\n  },\n};\n","import { type AiAdapter } from \"@inngest/ai\";\nimport { randomUUID } from \"crypto\";\nimport { z } from \"zod\";\nimport { createRoutingAgent, type Agent, RoutingAgent } from \"./agent\";\nimport { createState, State, type StateData } from \"./state\";\nimport { createTool } from \"./tool\";\nimport type { AgentResult, Message, UserMessage } from \"./types\";\nimport { type MaybePromise } from \"./util\";\nimport {\n  type HistoryConfig,\n  initializeThread,\n  loadThreadFromStorage,\n  saveThreadToStorage,\n} from \"./history\";\nimport {\n  StreamingContext,\n  createStepWrapper,\n  generateId,\n  type StreamingConfig,\n} from \"./streaming\";\nimport { getStepTools } from \"./util\";\n\n/**\n * Network represents a network of agents.\n */\nexport const createNetwork = <T extends StateData>(\n  opts: Network.Constructor<T>\n) => new Network(opts);\n\n/**\n * Network represents a network of agents.\n */\nexport class Network<T extends StateData> {\n  /**\n   * The name for the system of agents\n   */\n  name: string;\n\n  description?: string;\n\n  /**\n   * agents are all publicly available agents in the netwrok\n   */\n  agents: Map<string, Agent<T>>;\n\n  /**\n   * state is the entire agent's state.\n   */\n  state: State<T>;\n\n  /**\n   * defaultModel is the default model to use with the network.  This will not\n   * override an agent's specific model if the agent already has a model defined\n   * (eg. via withModel or via its constructor).\n   */\n  defaultModel?: AiAdapter.Any;\n\n  router?: Network.Router<T>;\n\n  /**\n   * maxIter is the maximum number of times the we can call agents before ending\n   * the network's run loop.\n   */\n  maxIter: number;\n\n  // _stack is an array of strings, each representing an agent name to call.\n  protected _stack: string[];\n\n  protected _counter = 0;\n\n  // _agents stores all agents.  note that you may not include eg. the\n  // defaultRoutingAgent within the network constructor, and you may return an\n  // agent in the router that's not included.  This is okay;  we store all\n  // agents referenced in the router here.\n  protected _agents: Map<string, Agent<T>>;\n\n  /**\n   * history config for managing thread creation and persistence\n   * used to create a new thread, load initial results/history and\n   * append new results to your database\n   */\n  public history?: HistoryConfig<T>;\n\n  constructor({\n    name,\n    description,\n    agents,\n    defaultModel,\n    maxIter,\n    defaultState,\n    router,\n    defaultRouter,\n    history,\n  }: Network.Constructor<T>) {\n    this.name = name;\n    this.description = description;\n    this.agents = new Map();\n    this._agents = new Map();\n    this.defaultModel = defaultModel;\n    this.router = defaultRouter ?? router;\n    this.maxIter = maxIter || 0;\n    this._stack = [];\n    this.history = history;\n\n    if (defaultState) {\n      this.state = defaultState;\n    } else {\n      this.state = createState<T>();\n    }\n\n    for (const agent of agents) {\n      // Store all agents publicly visible.\n      this.agents.set(agent.name, agent);\n      // Store an internal map of all agents referenced.\n      this._agents.set(agent.name, agent);\n    }\n  }\n\n  async availableAgents(\n    networkRun: NetworkRun<T> = new NetworkRun(this, new State())\n  ): Promise<Agent<T>[]> {\n    const available: Agent<T>[] = [];\n    const all = Array.from(this.agents.values());\n    for (const a of all) {\n      const enabled = a?.lifecycles?.enabled;\n      if (!enabled || (await enabled({ agent: a, network: networkRun }))) {\n        available.push(a);\n      }\n    }\n    return available;\n  }\n\n  /**\n   * addAgent adds a new agent to the network.\n   */\n  addAgent(agent: Agent<T>) {\n    this.agents.set(agent.name, agent);\n  }\n\n  /**\n   * run handles a given request using the network of agents.  It is not\n   * concurrency-safe; you can only call run on a network once, as networks are\n   * stateful.\n   *\n   */\n  public run(\n    ...[input, overrides]: Network.RunArgs<T>\n  ): Promise<NetworkRun<T>> {\n    // Automatically normalize a string clientTimestamp to a Date object.\n    if (\n      typeof input === \"object\" &&\n      typeof input.clientTimestamp === \"string\"\n    ) {\n      input.clientTimestamp = new Date(input.clientTimestamp);\n    }\n\n    let state: State<T>;\n    if (overrides?.state) {\n      if (overrides.state instanceof State) {\n        state = overrides.state;\n      } else {\n        const stateObj = overrides.state as {\n          data?: T;\n          _messages?: Message[];\n          _results?: AgentResult[];\n        };\n        state = new State<T>({\n          data: stateObj.data || ({} as T),\n          messages: stateObj._messages || [],\n          results: stateObj._results || [],\n        });\n      }\n    } else {\n      state = this.state?.clone() || new State<T>();\n    }\n\n    return new NetworkRun(this, state)[\"execute\"](input, overrides);\n  }\n}\n\n/**\n * defaultRoutingAgent is an AI agent that selects the appropriate agent from\n * the network to handle the incoming request.\n *\n * It is no set model and so relies on the presence of a default model in the\n * network or being explicitly given one.\n */\nlet defaultRoutingAgent: RoutingAgent<any> | undefined; // eslint-disable-line @typescript-eslint/no-explicit-any\n\nexport const getDefaultRoutingAgent = () => {\n  defaultRoutingAgent ??= createRoutingAgent({\n    name: \"Default routing agent\",\n\n    description:\n      \"Selects which agents to work on based off of the current prompt and input.\",\n\n    lifecycle: {\n      onRoute: ({ result }) => {\n        const tool = result.toolCalls[0];\n        if (!tool) {\n          return;\n        }\n\n        // Check if the done tool was called\n        if (tool.tool.name === \"done\") {\n          return undefined; // Signal to exit the agent loop\n        }\n\n        // Check if select_agent was called\n        if (tool.tool.name === \"select_agent\") {\n          if (\n            typeof tool.content === \"object\" &&\n            tool.content !== null &&\n            \"data\" in tool.content &&\n            typeof tool.content.data === \"string\"\n          ) {\n            return [tool.content.data];\n          }\n        }\n\n        return;\n      },\n    },\n\n    tools: [\n      createTool({\n        name: \"select_agent\",\n        description:\n          \"Select an agent to handle the next step of the conversation\",\n        parameters: z\n          .object({\n            name: z\n              .string()\n              .describe(\"The name of the agent that should handle the request\"),\n            reason: z\n              .string()\n              .optional()\n              .describe(\"Brief explanation of why this agent was chosen\"),\n          })\n          .strict(),\n        handler: ({ name }, { network }) => {\n          if (typeof name !== \"string\") {\n            throw new Error(\"The routing agent requested an invalid agent\");\n          }\n\n          const agent = network.agents.get(name);\n          if (agent === undefined) {\n            throw new Error(\n              `The routing agent requested an agent that doesn't exist: ${name}`\n            );\n          }\n\n          // This returns the agent name to call.  The default routing functon\n          // schedules this agent by inpsecting this name via the tool call output.\n          return agent.name;\n        },\n      }),\n\n      createTool({\n        name: \"done\",\n        description:\n          \"Signal that the conversation is complete and no more agents need to be called\",\n        parameters: z\n          .object({\n            summary: z\n              .string()\n              .optional()\n              .describe(\"Brief summary of what was accomplished\"),\n          })\n          .strict(),\n        handler: ({ summary }) => {\n          // Return a completion message\n          return summary || \"Conversation completed successfully\";\n        },\n      }),\n    ],\n\n    tool_choice: \"any\", // Allow the model to choose between select_agent or done\n\n    system: async ({ network }): Promise<string> => {\n      if (!network) {\n        throw new Error(\n          \"The routing agent can only be used within a network of agents\"\n        );\n      }\n\n      const agents = await network?.availableAgents();\n\n      return `You are the orchestrator between a group of agents. Each agent is suited for specific tasks and has a name, description, and tools.\n\nThe following agents are available:\n<agents>\n  ${agents\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .map((a: Agent<any>) => {\n      return `\n    <agent>\n      <name>${a.name}</name>\n      <description>${a.description}</description>\n      <tools>${JSON.stringify(Array.from(a.tools.values()))}</tools>\n    </agent>`;\n    })\n    .join(\"\\n\")}\n</agents>\n\nYour responsibilities:\n1. Analyze the conversation history and current state\n2. Determine if the request has been completed or if more work is needed\n3. Either:\n   - Call select_agent to route to the appropriate agent for the next step\n   - Call done if the conversation is complete or the user's request has been fulfilled\n\n<instructions>\n  - If the user's request has been addressed and no further action is needed, call the done tool\n  - If more work is needed, select the most appropriate agent based on their capabilities\n  - Consider the context and history when making routing decisions\n  - Be efficient - don't route to agents unnecessarily if the task is complete\n</instructions>`;\n    },\n  });\n\n  return defaultRoutingAgent;\n};\n\nexport namespace Network {\n  export type Constructor<T extends StateData> = {\n    name: string;\n    description?: string;\n    agents: Agent<T>[];\n    defaultModel?: AiAdapter.Any;\n    maxIter?: number;\n    // state is any pre-existing network state to use in this Network instance.  By\n    // default, new state is created without any history for every Network.\n    defaultState?: State<T>;\n    router?: Router<T>;\n    defaultRouter?: Router<T>;\n    history?: HistoryConfig<T>;\n  };\n\n  export type RunArgs<T extends StateData> = [\n    input: UserMessage | string,\n    overrides?: {\n      router?: Router<T>;\n      defaultRouter?: Router<T>;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      state?: State<T> | Record<string, any>;\n      streaming?: StreamingConfig;\n    },\n  ];\n\n  /**\n   * Router defines how a network coordinates between many agents.  A router is\n   * either a RoutingAgent which uses inference calls to choose the next Agent,\n   * or a function which chooses the next Agent to call.\n   *\n   * The function gets given the network, current state, future\n   * agentic calls, and the last inference result from the network.\n   *\n   */\n  export type Router<T extends StateData> =\n    | RoutingAgent<T>\n    | Router.FnRouter<T>;\n\n  export namespace Router {\n    /**\n     * FnRouter defines a function router which returns an Agent, an AgentRouter, or\n     * undefined if the network should stop.\n     *\n     * If the FnRouter returns an AgentRouter (an agent with the .route function),\n     * the agent will first be ran, then the `.route` function will be called.\n     *\n     */\n    export type FnRouter<T extends StateData> = (\n      args: Args<T>\n    ) => MaybePromise<RoutingAgent<T> | Agent<T> | Agent<T>[] | undefined>;\n\n    export interface Args<T extends StateData> {\n      /**\n       * input is the input called to the network (always the string content for backwards compatibility)\n       */\n      input: string;\n\n      /**\n       * userMessage is the rich UserMessage object if provided (new in Phase 1)\n       * Contains client state, timestamps, and optional system prompts\n       */\n      userMessage?: UserMessage;\n\n      /**\n       * Network is the network that this router is coordinating.  Network state\n       * is accessible via `network.state`.\n       */\n      network: NetworkRun<T>;\n\n      /**\n       * stack is an ordered array of agents that will be called next.\n       */\n      stack: Agent<T>[];\n\n      /**\n       * callCount is the number of current agent invocations that the network\n       * has made.  This is a shorthand for `network.state.results.length`.\n       */\n      callCount: number;\n\n      /**\n       * lastResult is the last inference result that the network made.  This is\n       * a shorthand for `network.state.results.pop()`.\n       */\n      lastResult?: AgentResult;\n    }\n  }\n}\n\nexport class NetworkRun<T extends StateData> extends Network<T> {\n  constructor(network: Network<T>, state: State<T>) {\n    super({\n      name: network.name,\n      description: network.description,\n      agents: Array.from(network.agents.values()),\n      defaultModel: network.defaultModel,\n      defaultState: network.state,\n      router: network.router,\n      maxIter: network.maxIter,\n      history: network.history,\n    });\n\n    this.state = state;\n  }\n\n  public override run(): never {\n    throw new Error(\"NetworkRun does not support run\");\n  }\n\n  public override async availableAgents(): Promise<Agent<T>[]> {\n    return super.availableAgents(this);\n  }\n\n  /**\n   * Schedule is used to push an agent's run function onto the stack.\n   */\n  schedule(agentName: string) {\n    this[\"_stack\"].push(agentName);\n  }\n\n  private async execute(\n    ...[input, overrides]: Network.RunArgs<T>\n  ): Promise<this> {\n    // Generate network run ID inside Inngest steps to ensure deterministic replay behavior\n    const stepTools = await getStepTools();\n    let networkRunId: string;\n\n    if (stepTools) {\n      // Use Inngest steps for deterministic ID generation\n      networkRunId = await stepTools.run(\"generate-network-id\", () => {\n        return randomUUID();\n      });\n    } else {\n      // Fallback for non-Inngest contexts\n      networkRunId = randomUUID();\n    }\n\n    const streamingPublish = overrides?.streaming?.publish;\n    let streamingContext: StreamingContext | undefined;\n\n    // If history.get is configured AND the state is empty, use it to load initial history\n    // When passing passing in messages from the client, history.get() is disabled - allowing the client to maintain conversation state and send it with each request\n    // Enables a client-authoritative pattern where the UI maintains conversation state and sends it with each request. Allows `history.get()` to serve as a fallback for new threads or recovery\n\n    // Extract string content for history functions that expect string input\n    const inputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    // Initialize conversation thread: Creates a new thread or auto-generates if needed\n    // Capture whether the client provided a threadId BEFORE initialization. If absent, this\n    // implies a brand-new thread and we can skip the initial history load (no-op DB read).\n    const hadClientThreadId = Boolean(this.state.threadId);\n    await initializeThread({\n      state: this.state,\n      history: this.history,\n      input: inputContent,\n      network: this,\n    });\n\n    // Persist the user's message at the beginning of the run for resilience\n    if (this.history?.appendUserMessage) {\n      let userMessage: {\n        id: string;\n        content: string;\n        role: \"user\";\n        timestamp: Date;\n      };\n\n      if (typeof input === \"object\" && input !== null && \"id\" in input) {\n        // Input is a UserMessage object - extract data from it\n        const userInput = input;\n\n        // Ensure clientTimestamp is a Date object before assignment\n        const timestamp =\n          userInput.clientTimestamp instanceof Date\n            ? userInput.clientTimestamp\n            : userInput.clientTimestamp\n              ? new Date(userInput.clientTimestamp)\n              : new Date();\n\n        userMessage = {\n          id: userInput.id,\n          content: userInput.content,\n          role: \"user\",\n          timestamp,\n        };\n      } else {\n        // Input is a string - generate a new ID\n        userMessage = {\n          id: randomUUID(),\n          content: input,\n          role: \"user\",\n          timestamp: new Date(),\n        };\n      }\n\n      await this.history.appendUserMessage({\n        state: this.state,\n        network: this,\n        input: inputContent,\n        threadId: this.state.threadId,\n        userMessage,\n        step: stepTools || undefined,\n      });\n    }\n\n    // Load existing conversation history from storage only when the client provided a threadId.\n    // If the threadId was omitted (new thread created this run), skip the initial get().\n    if (hadClientThreadId) {\n      await loadThreadFromStorage({\n        state: this.state,\n        history: this.history,\n        input: inputContent,\n        network: this,\n      });\n    }\n\n    // Prepare streaming context after thread initialization\n    if (streamingPublish) {\n      streamingContext = StreamingContext.fromNetworkState(this.state, {\n        publish: streamingPublish,\n        runId: networkRunId,\n        messageId: networkRunId, // Use networkRunId as messageId for network-level events\n        scope: \"network\",\n        simulateChunking: overrides?.streaming?.simulateChunking,\n      });\n      await streamingContext.publishEvent({\n        event: \"run.started\",\n        data: {\n          runId: networkRunId,\n          scope: \"network\",\n          name: this.name,\n          messageId: networkRunId, // Network events use networkRunId as messageId\n          threadId: this.state.threadId,\n        },\n      });\n    }\n\n    // Wrap step tools for automatic step lifecycle events\n    const step = await getStepTools();\n    const wrappedStep = createStepWrapper(step, streamingContext);\n\n    const available = await this.availableAgents();\n    if (available.length === 0) {\n      throw new Error(\"no agents enabled in network\");\n    }\n\n    // Store initial result count to track new results\n    // Used to track new results in history.appendResults\n    const initialResultCount = this.state.results.length;\n\n    try {\n      // If there's no default agent used to run the request, use our internal\n      // routing agent which attempts to figure out the best agent to choose based\n      // off of the network.\n      const next = await this.getNextAgents(\n        input, // Pass full UserMessage object, not extracted content\n        overrides?.router || overrides?.defaultRouter || this.router\n      );\n      if (!next?.length) {\n        // TODO: If call count is 0, error.\n        return this;\n      }\n\n      // Schedule the agent to run on our stack, then start popping off the stack.\n      for (const agent of next) {\n        this.schedule(agent.name);\n      }\n\n      while (\n        this._stack.length > 0 &&\n        (this.maxIter === 0 || this._counter < this.maxIter)\n      ) {\n        // XXX: It would be possible to parallel call these agents here by\n        // fetching the entire stack, parallel running, then awaiting the\n        // responses.   However, this confuses history and we'll take our time to\n        // introduce parallelisation after the foundations are set.\n\n        // Fetch the agent we need to call next off of the stack.\n        const agentName = this._stack.shift();\n\n        // Grab agents from the private map, as this may have been introduced in\n        // the router.\n        const agent = agentName && this._agents.get(agentName);\n        if (!agent) {\n          // We're done.\n          // Emit run.completed and stream.ended if streaming\n          if (streamingContext) {\n            await streamingContext.publishEvent({\n              event: \"run.completed\",\n              data: {\n                runId: networkRunId,\n                scope: \"network\",\n                name: this.name,\n                messageId: networkRunId, // Use networkRunId for network completion\n              },\n            });\n            await streamingContext.publishEvent({\n              event: \"stream.ended\",\n              data: {\n                scope: \"network\",\n                messageId: networkRunId,\n              },\n            });\n          }\n          return this;\n        }\n\n        // We force Agent to emit structured output in case of the use of tools by\n        // setting maxIter to 0.\n        // Generate unique IDs for this agent's execution using durable steps\n        let agentRunId: string;\n        let agentMessageId: string;\n\n        if (stepTools) {\n          // Use Inngest steps for deterministic agent ID generation\n          const agentIds = await stepTools.run(\n            `generate-agent-ids-${this._counter}`,\n            () => {\n              return {\n                agentRunId: generateId(),\n                agentMessageId: randomUUID(),\n              };\n            }\n          );\n          agentRunId = agentIds.agentRunId;\n          agentMessageId = agentIds.agentMessageId;\n        } else {\n          // Fallback for non-Inngest contexts\n          agentRunId = generateId();\n          agentMessageId = randomUUID();\n        }\n\n        // Create agent streaming context that shares the sequence counter\n        let agentStreamingContext: StreamingContext | undefined;\n        if (streamingContext) {\n          // Create context with shared sequence counter but agent-specific messageId\n          agentStreamingContext =\n            streamingContext.createContextWithSharedSequence({\n              runId: agentRunId,\n              messageId: agentMessageId,\n              scope: \"agent\",\n            });\n\n          await streamingContext.publishEvent({\n            event: \"run.started\",\n            data: {\n              runId: agentRunId,\n              parentRunId: networkRunId,\n              scope: \"agent\",\n              name: agent.name,\n              messageId: agentMessageId, // Use agent-specific messageId\n            },\n          });\n        }\n\n        const call = await agent.run(inputContent, {\n          network: this,\n          maxIter: 0,\n          // Provide streaming context so the agent can emit part/text/tool events\n          streamingContext: agentStreamingContext,\n          // Provide wrapped step tools for automatic step lifecycle events\n          step: wrappedStep,\n        });\n\n        // CRITICAL FIX: Set the canonical message ID on the AgentResult\n        // This ensures the streaming agentMessageId becomes the persisted message_id\n        call.id = agentMessageId;\n\n        if (agentStreamingContext) {\n          await agentStreamingContext.publishEvent({\n            event: \"run.completed\",\n            data: {\n              runId: agentRunId,\n              scope: \"agent\",\n              name: agent.name,\n              messageId: agentMessageId, // Include agent-specific messageId in completion event\n            },\n          });\n        }\n        this._counter += 1;\n\n        // Ensure that we store the call network history.\n        this.state.appendResult(call);\n\n        // Here we face a problem: what's the definition of done?   An agent may\n        // have just been called with part of the information to solve an input.\n        // We may need to delegate to another agent.\n        //\n        // In this case, we defer to the router provided to give us next steps.\n        // By default, this is an agentic router which takes the current state,\n        // agents, then figures out next steps.  This can, and often should, be\n        // custom code.\n        const next = await this.getNextAgents(\n          input, // Pass full UserMessage object, not extracted content\n          overrides?.router || overrides?.defaultRouter || this.router\n        );\n\n        for (const a of next || []) {\n          this.schedule(a.name);\n        }\n      }\n\n      // Save new network results to storage: Persists all new AgentResults generated\n      // during this network run (from all agents that executed). Only saves the new\n      // results, excluding any historical results that were loaded at the start.\n      await saveThreadToStorage({\n        state: this.state,\n        history: this.history,\n        input: inputContent,\n        initialResultCount,\n        network: this,\n      });\n    } catch (error) {\n      // Emit error events for network streaming\n      if (streamingContext) {\n        try {\n          await streamingContext.publishEvent({\n            event: \"run.failed\",\n            data: {\n              runId: networkRunId,\n              scope: \"network\",\n              name: this.name,\n              messageId: networkRunId, // Use networkRunId for network error events\n              error: error instanceof Error ? error.message : String(error),\n              recoverable: false,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent masking the original error\n          console.warn(\"Failed to publish run.failed event:\", streamingError);\n        }\n      }\n      // Re-throw the original error\n      throw error;\n    } finally {\n      // Always emit completion events for network streaming\n      if (streamingContext) {\n        try {\n          await streamingContext.publishEvent({\n            event: \"run.completed\",\n            data: {\n              runId: networkRunId,\n              scope: \"network\",\n              name: this.name,\n              messageId: networkRunId, // Use networkRunId for network completion in finally block\n            },\n          });\n          await streamingContext.publishEvent({\n            event: \"stream.ended\",\n            data: {\n              scope: \"network\",\n              messageId: networkRunId,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent breaking the application\n          console.warn(\"Failed to publish completion events:\", streamingError);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  private async getNextAgents(\n    input: UserMessage | string,\n    router?: Network.Router<T>\n  ): Promise<Agent<T>[] | undefined> {\n    // A router may do one of two things:\n    //\n    //   1. Return one or more Agents to run\n    //   2. Return undefined, meaning we're done.\n    //\n    // It can do this by using code, or by calling routing agents directly.\n    if (!router && !this.defaultModel) {\n      throw new Error(\n        \"No router or model defined in network.  You must pass a router or a default model to use the built-in agentic router.\"\n      );\n    }\n    if (!router) {\n      router = getDefaultRoutingAgent();\n    }\n    if (router instanceof RoutingAgent) {\n      // RoutingAgents expect string input, so extract content from UserMessage\n      const inputContent =\n        typeof input === \"object\" && input !== null && \"content\" in input\n          ? input.content\n          : input;\n      return await this.getNextAgentsViaRoutingAgent(router, inputContent);\n    }\n\n    // This is a function call which determines the next agent to call.  Note that the result\n    // of this function call may be another RoutingAgent.\n    const stack: Agent<T>[] = this._stack.map((name) => {\n      const agent = this._agents.get(name);\n      if (!agent) {\n        throw new Error(`unknown agent in the network stack: ${name}`);\n      }\n      return agent;\n    });\n\n    // Extract string content for router (routers always receive string for backwards compatibility)\n    const routerInputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    const agent = await router({\n      input: routerInputContent, // Always pass string content for backwards compatibility\n      userMessage:\n        typeof input === \"object\" && input !== null && \"content\" in input\n          ? input\n          : undefined,\n      network: this,\n      stack,\n      lastResult: this.state.results[this.state.results.length - 1],\n      callCount: this._counter,\n    });\n\n    if (!agent) {\n      return;\n    }\n    if (agent instanceof RoutingAgent) {\n      // Functions may also return routing agents - extract content for RoutingAgent\n      const inputContent =\n        typeof input === \"object\" && input !== null && \"content\" in input\n          ? input.content\n          : input;\n      return await this.getNextAgentsViaRoutingAgent(agent, inputContent);\n    }\n\n    for (const a of Array.isArray(agent) ? agent : [agent]) {\n      // Ensure this agent is part of the network.  If not, we're going to\n      // automatically add it.\n      if (!this._agents.has(a.name)) {\n        this._agents.set(a.name, a);\n      }\n    }\n\n    return Array.isArray(agent) ? agent : [agent];\n  }\n\n  private async getNextAgentsViaRoutingAgent(\n    routingAgent: RoutingAgent<T>,\n    input: string\n  ): Promise<Agent<T>[] | undefined> {\n    const result = await routingAgent.run(input, {\n      network: this,\n      model: routingAgent.model || this.defaultModel,\n    });\n\n    const agentNames = routingAgent.lifecycles.onRoute({\n      result,\n      agent: routingAgent,\n      network: this,\n    });\n\n    return (agentNames || [])\n      .map((name) => this.agents.get(name))\n      .filter(Boolean) as Agent<T>[];\n  }\n}\n","import type { JSONSchema } from \"@dmitryrechkin/json-schema-to-zod\";\nimport { type AiAdapter } from \"@inngest/ai\";\nimport { Client as MCPClient } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StreamableHTTPClientTransport } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport { SSEClientTransport } from \"@modelcontextprotocol/sdk/client/sse.js\";\nimport { WebSocketClientTransport } from \"@modelcontextprotocol/sdk/client/websocket.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport { type Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport { ListToolsResultSchema } from \"@modelcontextprotocol/sdk/types.js\";\nimport { EventSource } from \"eventsource\";\nimport { randomUUID } from \"crypto\";\nimport { referenceFunction, type Inngest, type GetStepTools } from \"inngest\";\nimport { errors } from \"inngest/internals\";\nimport { type InngestFunction } from \"inngest\";\nimport { type MinimalEventPayload } from \"inngest/types\";\nimport type { ZodType } from \"zod\";\nimport { createAgenticModelFromAiAdapter, type AgenticModel } from \"./model\";\nimport { createNetwork, NetworkRun } from \"./network\";\nimport { State, type StateData } from \"./state\";\nimport { type MCP, type Tool } from \"./tool\";\nimport {\n  AgentResult,\n  type Message,\n  type ToolResultMessage,\n  type UserMessage,\n} from \"./types\";\nimport {\n  getInngestFnInput,\n  getStepTools,\n  isInngestFn,\n  type MaybePromise,\n} from \"./util\";\nimport {\n  type HistoryConfig,\n  initializeThread,\n  loadThreadFromStorage,\n  saveThreadToStorage,\n} from \"./history\";\n// Streaming integration will be handled at the network level for now\nimport {\n  StreamingContext,\n  createStepWrapper,\n  generateId,\n  type StreamingConfig,\n} from \"./streaming\";\n\n/**\n * Agent represents a single agent, responsible for a set of tasks.\n */\nexport const createAgent = <T extends StateData>(opts: Agent.Constructor<T>) =>\n  new Agent(opts);\n\nexport const createRoutingAgent = <T extends StateData>(\n  opts: Agent.RoutingConstructor<T>\n) => new RoutingAgent(opts);\n\n/**\n * Agent represents a single agent, responsible for a set of tasks.\n */\nexport class Agent<T extends StateData> {\n  /**\n   * name is the name of the agent.\n   */\n  name: string;\n\n  /**\n   * description is the description of the agent.\n   */\n  description: string;\n\n  /**\n   * system is the system prompt for the agent.\n   */\n  system: string | ((ctx: { network?: NetworkRun<T> }) => MaybePromise<string>);\n\n  /**\n   * Assistant is the assistent message used for completion, if any.\n   */\n  assistant: string;\n\n  /**\n   * tools are a list of tools that this specific agent has access to.\n   */\n  tools: Map<string, Tool.Any>;\n\n  /**\n   * tool_choice allows you to specify whether tools are automatically.  this defaults\n   * to \"auto\", allowing the model to detect when to call tools automatically.  Choices are:\n   *\n   * - \"auto\": allow the model to choose tools automatically\n   * - \"any\": force the use of any tool in the tools map\n   * - string: force the name of a particular tool\n   */\n  tool_choice?: Tool.Choice;\n\n  /**\n   * lifecycles are programmatic hooks used to manage the agent.\n   */\n  lifecycles: Agent.Lifecycle<T> | Agent.RoutingLifecycle<T> | undefined;\n\n  /**\n   * model is the step caller to use for this agent.  This allows the agent\n   * to use a specific model which may be different to other agents in the\n   * system\n   */\n  model: AiAdapter.Any | undefined;\n\n  /**\n   * mcpServers is a list of MCP (model-context-protocol) servers which can\n   * provide tools to the agent.\n   */\n  mcpServers?: MCP.Server[];\n\n  /**\n   * history configuration for managing conversation history\n   */\n  private history?: HistoryConfig<T>;\n\n  // _mcpInit records whether the MCP tool list has been initialized.\n  private _mcpClients: MCPClient[];\n\n  constructor(opts: Agent.Constructor<T> | Agent.RoutingConstructor<T>) {\n    this.name = opts.name;\n    this.description = opts.description || \"\";\n    this.system = opts.system;\n    this.assistant = opts.assistant || \"\";\n    this.tools = new Map();\n    this.tool_choice = opts.tool_choice;\n    this.lifecycles = opts.lifecycle;\n    this.model = opts.model;\n    this.history = opts.history;\n    this.setTools(opts.tools);\n    this.mcpServers = opts.mcpServers;\n    this._mcpClients = [];\n  }\n\n  private setTools(tools: Agent.Constructor<T>[\"tools\"]): void {\n    for (const tool of tools || []) {\n      if (isInngestFn(tool)) {\n        this.tools.set(tool[\"absoluteId\"], {\n          name: tool[\"absoluteId\"],\n          description: tool.description,\n          // TODO Should we error here if we can't find an input schema?\n          parameters: getInngestFnInput(tool),\n          handler: async (input: MinimalEventPayload[\"data\"], opts) => {\n            // Doing this late means a potential throw if we use the agent in a\n            // non-Inngest environment. We could instead calculate the tool list\n            // JIT and omit any Inngest tools if we're not in an Inngest\n            // context.\n            const step = await getStepTools();\n            if (!step) {\n              throw new Error(\"Inngest tool called outside of Inngest context\");\n            }\n\n            const stepId = `${opts.agent.name}/tools/${tool[\"absoluteId\"]}`;\n\n            return step.invoke(stepId, {\n              function: referenceFunction({\n                appId: (tool[\"client\"] as Inngest.Any)[\"id\"],\n                functionId: tool.id(),\n              }),\n              data: input,\n            });\n          },\n        });\n      } else {\n        this.tools.set(tool.name, tool);\n      }\n    }\n  }\n\n  withModel(model: AiAdapter.Any): Agent<T> {\n    return new Agent({\n      name: this.name,\n      description: this.description,\n      system: this.system,\n      assistant: this.assistant,\n      tools: Array.from(this.tools.values()),\n      lifecycle: this.lifecycles,\n      model,\n    });\n  }\n\n  /**\n   * Run runs an agent with the given user input, treated as a user message.  If\n   * the input is an empty string, only the system prompt will execute.\n   */\n  async run(\n    input: UserMessage | string,\n    {\n      model,\n      network,\n      state,\n      maxIter = 0,\n      streaming,\n      streamingContext,\n      step,\n    }: Agent.RunOptions<T> | undefined = {}\n  ): Promise<AgentResult> {\n    // Attempt to resolve the MCP tools, if we haven't yet done so.\n    await this.initMCP();\n\n    const rawModel = model || this.model || network?.defaultModel;\n    if (!rawModel) {\n      throw new Error(\"No model provided to agent\");\n    }\n\n    const p = createAgenticModelFromAiAdapter(rawModel);\n\n    // input state always overrides the network state.\n    const s = state || network?.state || new State();\n    const run = new NetworkRun(\n      network || createNetwork<T>({ name: \"default\", agents: [] }),\n      s\n    );\n\n    // Handle standalone agent streaming (ignored if part of a network)\n    let standaloneStreamingContext: StreamingContext | undefined;\n    let standaloneWrappedStep: GetStepTools<Inngest.Any> | undefined;\n    if (!network && streaming?.publish) {\n      // Generate IDs for this standalone agent run using Inngest steps for deterministic replay\n      const stepTools = await getStepTools();\n      let agentRunId: string;\n      let messageId: string;\n\n      if (stepTools) {\n        // Use Inngest steps for deterministic ID generation\n        const ids = await stepTools.run(\"generate-standalone-agent-ids\", () => {\n          return {\n            agentRunId: generateId(),\n            messageId: randomUUID(),\n          };\n        });\n        agentRunId = ids.agentRunId;\n        messageId = ids.messageId;\n      } else {\n        // Fallback for non-Inngest contexts\n        agentRunId = generateId();\n        messageId = randomUUID();\n      }\n\n      // Create streaming context for this standalone agent\n      standaloneStreamingContext = StreamingContext.fromNetworkState(s, {\n        publish: streaming.publish,\n        runId: agentRunId,\n        messageId,\n        scope: \"agent\",\n        simulateChunking: streaming.simulateChunking,\n      });\n\n      // Create wrapped step for standalone agent streaming\n      standaloneWrappedStep = createStepWrapper(\n        stepTools,\n        standaloneStreamingContext\n      );\n\n      // Emit agent run.started event\n      await standaloneStreamingContext.publishEvent({\n        event: \"run.started\",\n        data: {\n          runId: agentRunId,\n          scope: \"agent\",\n          name: this.name,\n          messageId,\n          threadId: s.threadId,\n        },\n      });\n    }\n\n    // Use standalone streaming context if available, otherwise use network-provided context\n    const effectiveStreamingContext =\n      streamingContext || standaloneStreamingContext;\n    // Use standalone wrapped step if available, otherwise use network-provided step\n    const effectiveStep: GetStepTools<Inngest.Any> | undefined =\n      step || standaloneWrappedStep;\n\n    // Note: Streaming is controlled at the network level when part of a network.\n    // For standalone agents, streaming is controlled by the streaming parameter.\n\n    // Extract string content for history functions that expect string input\n    const inputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    // Initialize conversation thread: Creates a new thread or auto-generates if needed\n    await initializeThread({\n      state: s,\n      history: this.history,\n      input: inputContent,\n      network: run,\n    });\n\n    // Load existing conversation history from storage: If threadId exists and history.get() is configured\n    await loadThreadFromStorage({\n      state: s,\n      history: this.history,\n      input: inputContent,\n      network: run,\n    });\n\n    // Get formatted history and initial prompt\n    let history = s ? s.formatHistory() : [];\n    let prompt = await this.agentPrompt(input, run);\n    let result = new AgentResult(\n      this.name,\n      [],\n      [],\n      new Date(),\n      prompt,\n      history,\n      \"\"\n    );\n    let hasMoreActions = true;\n    let iter = 0;\n\n    // Store initial result count to track new results\n    const initialResultCount = s.results.length;\n\n    try {\n      do {\n        // Call lifecycles each time we perform inference.\n        if (this.lifecycles?.onStart) {\n          const modified = await this.lifecycles.onStart({\n            agent: this,\n            network: run,\n            input: inputContent,\n            prompt,\n            history,\n          });\n\n          if (modified.stop) {\n            // We allow users to prevent calling the LLM directly here.\n            return result;\n          }\n\n          prompt = modified.prompt;\n          history = modified.history;\n        }\n\n        const inference = await this.performInference(\n          p,\n          prompt,\n          history,\n          run,\n          effectiveStreamingContext,\n          effectiveStep\n        );\n\n        hasMoreActions = Boolean(\n          this.tools.size > 0 &&\n            inference.output.length &&\n            inference.output[inference.output.length - 1]!.stop_reason !==\n              \"stop\"\n        );\n\n        result = inference;\n        // Set the canonical message ID from streaming context for standalone agents\n        if (standaloneStreamingContext) {\n          result.id = standaloneStreamingContext.messageId;\n        }\n        history = [...inference.output];\n        iter++;\n      } while (hasMoreActions && iter < maxIter);\n\n      if (this.lifecycles?.onFinish) {\n        result = await this.lifecycles.onFinish({\n          agent: this,\n          network: run,\n          result,\n        });\n      }\n\n      // Note that the routing lifecycles aren't called by the agent.  They're called\n      // by the network.\n\n      // Save new conversation results to storage: Persists only the new AgentResults\n      // generated during this run (excluding any historical results that were loaded).\n      // This allows the conversation to be continued in future runs with full context.\n      await saveThreadToStorage({\n        state: s,\n        history: this.history,\n        input: inputContent,\n        initialResultCount,\n        network: run,\n      });\n    } catch (error) {\n      // Emit error events for standalone agent streaming\n      if (standaloneStreamingContext) {\n        try {\n          await standaloneStreamingContext.publishEvent({\n            event: \"run.failed\",\n            data: {\n              runId: standaloneStreamingContext.runId,\n              scope: \"agent\",\n              name: this.name,\n              error: error instanceof Error ? error.message : String(error),\n              recoverable: false,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent masking the original error\n          console.warn(\"Failed to publish run.failed event:\", streamingError);\n        }\n      }\n      // Re-throw the original error\n      throw error;\n    } finally {\n      // Always emit completion events for standalone agent streaming\n      if (standaloneStreamingContext) {\n        try {\n          await standaloneStreamingContext.publishEvent({\n            event: \"run.completed\",\n            data: {\n              runId: standaloneStreamingContext.runId,\n              scope: \"agent\",\n              name: this.name,\n            },\n          });\n          await standaloneStreamingContext.publishEvent({\n            event: \"stream.ended\",\n            data: {\n              scope: \"agent\",\n              messageId: standaloneStreamingContext.messageId,\n            },\n          });\n        } catch (streamingError) {\n          // Swallow streaming errors to prevent breaking the application\n          console.warn(\"Failed to publish completion events:\", streamingError);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  private async performInference(\n    p: AgenticModel.Any,\n    prompt: Message[],\n    history: Message[],\n    network: NetworkRun<T>,\n    streamingContext?: StreamingContext,\n    step?: GetStepTools<Inngest.Any>\n  ): Promise<AgentResult> {\n    const { output, raw } = await p.infer(\n      this.name,\n      prompt.concat(history),\n      Array.from(this.tools.values()),\n      this.tool_choice || \"auto\"\n    );\n\n    // Now that we've made the call, we instantiate a new AgentResult for\n    // lifecycles and history.\n    let result = new AgentResult(\n      this.name,\n      output,\n      [],\n      new Date(),\n      prompt,\n      history,\n      typeof raw === \"string\" ? raw : JSON.stringify(raw)\n    );\n    if (this.lifecycles?.onResponse) {\n      result = await this.lifecycles.onResponse({\n        agent: this,\n        network,\n        result,\n      });\n    }\n\n    // Fallback streaming of assistant text if streaming context exists\n    if (streamingContext) {\n      // Find the last assistant text message\n      const lastTextMsg = [...result.output]\n        .reverse()\n        .find((m) => m.type === \"text\" && m.role === \"assistant\");\n      let content = \"\";\n      if (lastTextMsg && lastTextMsg.type === \"text\") {\n        const anyMsg = lastTextMsg as unknown as {\n          content: string | Array<{ type: \"text\"; text: string }>;\n        };\n        if (typeof anyMsg.content === \"string\") {\n          content = anyMsg.content;\n        } else if (Array.isArray(anyMsg.content)) {\n          content = anyMsg.content.map((c) => c.text).join(\"\");\n        }\n      }\n\n      if (content && content.length > 0) {\n        // Generate partId deterministically within a step to avoid replay issues\n        const stepTools = step || (await getStepTools());\n        const partId = stepTools\n          ? await stepTools.run(\n              `generate-text-part-id-${streamingContext.messageId}`,\n              () => {\n                return streamingContext.generatePartId();\n              }\n            )\n          : streamingContext.generatePartId();\n\n        await streamingContext.publishEvent({\n          event: \"part.created\",\n          data: {\n            partId,\n            runId: streamingContext.runId,\n            messageId: streamingContext.messageId,\n            type: \"text\",\n            metadata: { agentName: this.name },\n          },\n        });\n\n        if (streamingContext.isSimulatedChunking()) {\n          const chunkSize = 50;\n          for (let i = 0; i < content.length; i += chunkSize) {\n            await streamingContext.publishEvent({\n              event: \"text.delta\",\n              data: {\n                partId,\n                messageId: streamingContext.messageId,\n                delta: content.slice(i, i + chunkSize),\n              },\n            });\n          }\n        } else {\n          // Single delta when not simulating chunking\n          await streamingContext.publishEvent({\n            event: \"text.delta\",\n            data: {\n              partId,\n              messageId: streamingContext.messageId,\n              delta: content,\n            },\n          });\n        }\n\n        await streamingContext.publishEvent({\n          event: \"part.completed\",\n          data: {\n            partId,\n            runId: streamingContext.runId,\n            messageId: streamingContext.messageId,\n            type: \"text\",\n            finalContent: content,\n          },\n        });\n      }\n    }\n\n    // And ensure we invoke any call from the agent, streaming tool I/O if possible\n    const toolCallOutput = await this.invokeTools(\n      result.output,\n      network,\n      streamingContext,\n      step\n    );\n    if (toolCallOutput.length > 0) {\n      result.toolCalls = result.toolCalls.concat(toolCallOutput);\n    }\n\n    return result;\n  }\n\n  /**\n   * invokeTools takes output messages from an inference call then invokes any tools\n   * in the message responses.\n   */\n  private async invokeTools(\n    msgs: Message[],\n    network: NetworkRun<T>,\n    streamingContext?: StreamingContext,\n    step?: GetStepTools<Inngest.Any>\n  ): Promise<ToolResultMessage[]> {\n    const output: ToolResultMessage[] = [];\n    // Best-effort streaming for tool execution: emit tool-call and output deltas via network streaming if available\n    // Determine if a StreamingContext exists by checking for a symbol on step wrapper (not exposed); for now rely on model-level streaming additions later\n\n    for (const msg of msgs) {\n      if (msg.type !== \"tool_call\") {\n        continue;\n      }\n\n      if (!Array.isArray(msg.tools)) {\n        continue;\n      }\n\n      for (const tool of msg.tools) {\n        const found = this.tools.get(tool.name);\n        if (!found) {\n          throw new Error(\n            `Inference requested a non-existent tool: ${tool.name}`\n          );\n        }\n\n        // Stream tool arguments if context available\n        const toolArgsJson = JSON.stringify(tool.input ?? {});\n        if (streamingContext) {\n          // Generate partId deterministically within a step to avoid replay issues\n          const stepTools = step || (await getStepTools());\n          const toolCallPartId = stepTools\n            ? await stepTools.run(\n                `generate-tool-part-id-${streamingContext.messageId}-${tool.name}`,\n                () => {\n                  return streamingContext.generatePartId();\n                }\n              )\n            : streamingContext.generatePartId();\n\n          await streamingContext.publishEvent({\n            event: \"part.created\",\n            data: {\n              partId: toolCallPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-call\",\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n          if (streamingContext.isSimulatedChunking()) {\n            const argChunkSize = 50;\n            for (let i = 0; i < toolArgsJson.length; i += argChunkSize) {\n              await streamingContext.publishEvent({\n                event: \"tool_call.arguments.delta\",\n                data: {\n                  partId: toolCallPartId,\n                  delta: toolArgsJson.slice(i, i + argChunkSize),\n                  toolName: i === 0 ? tool.name : undefined,\n                  messageId: streamingContext.messageId,\n                },\n              });\n            }\n          } else {\n            await streamingContext.publishEvent({\n              event: \"tool_call.arguments.delta\",\n              data: {\n                partId: toolCallPartId,\n                delta: toolArgsJson,\n                toolName: tool.name,\n                messageId: streamingContext.messageId,\n              },\n            });\n          }\n          await streamingContext.publishEvent({\n            event: \"part.completed\",\n            data: {\n              partId: toolCallPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-call\",\n              finalContent: tool.input ?? {},\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n        }\n\n        // Call this tool.\n        //\n        // XXX: You might expect this to be wrapped in a step, but each tool can\n        // use multiple step tools, eg. `step.run`, then `step.waitForEvent` for\n        // human in the loop tasks.\n        //\n\n        type ToolHandlerResult =\n          | { data: unknown }\n          | { error: ReturnType<typeof errors.serializeError> };\n\n        const result: ToolHandlerResult = await Promise.resolve(\n          found.handler(tool.input, {\n            agent: this,\n            network,\n            step: step as GetStepTools<Inngest.Any>,\n          })\n        )\n          .then((r) => {\n            return {\n              data:\n                typeof r === \"undefined\"\n                  ? `${tool.name} successfully executed`\n                  : r,\n            };\n          })\n          .catch((err: Error) => {\n            return { error: errors.serializeError(err) };\n          });\n\n        // Stream tool output if context available\n        if (streamingContext) {\n          // Generate partId deterministically within a step to avoid replay issues\n          const stepTools = step || (await getStepTools());\n          const outputPartId = stepTools\n            ? await stepTools.run(\n                `generate-output-part-id-${streamingContext.messageId}-${tool.name}`,\n                () => {\n                  return streamingContext.generatePartId();\n                }\n              )\n            : streamingContext.generatePartId();\n\n          await streamingContext.publishEvent({\n            event: \"part.created\",\n            data: {\n              partId: outputPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-output\",\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n\n          const resultJson = JSON.stringify(result);\n          if (streamingContext.isSimulatedChunking()) {\n            const outChunk = 80;\n            for (let i = 0; i < resultJson.length; i += outChunk) {\n              await streamingContext.publishEvent({\n                event: \"tool_call.output.delta\",\n                data: {\n                  partId: outputPartId,\n                  delta: resultJson.slice(i, i + outChunk),\n                  messageId: streamingContext.messageId,\n                },\n              });\n            }\n          } else {\n            await streamingContext.publishEvent({\n              event: \"tool_call.output.delta\",\n              data: {\n                partId: outputPartId,\n                delta: resultJson,\n                messageId: streamingContext.messageId,\n              },\n            });\n          }\n\n          await streamingContext.publishEvent({\n            event: \"part.completed\",\n            data: {\n              partId: outputPartId,\n              runId: streamingContext.runId,\n              messageId: streamingContext.messageId,\n              type: \"tool-output\",\n              finalContent: result,\n              metadata: { toolName: tool.name, agentName: this.name },\n            },\n          });\n        }\n\n        output.push({\n          role: \"tool_result\",\n          type: \"tool_result\",\n          tool: {\n            type: \"tool\",\n            id: tool.id,\n            name: tool.name,\n            input: tool.input.arguments as Record<string, unknown>,\n          },\n\n          content: result,\n          stop_reason: \"tool\",\n        });\n      }\n    }\n\n    return output;\n  }\n\n  private async agentPrompt(\n    input: UserMessage | string,\n    network?: NetworkRun<T>\n  ): Promise<Message[]> {\n    // Prompt returns the full prompt for the current agent.  This does NOT\n    // include the existing network's state as part of the prompt.\n    //\n    // Note that the agent's system message always comes first.\n    const systemContent =\n      typeof this.system === \"string\"\n        ? this.system\n        : await this.system({ network });\n\n    // Extract content and optional system prompt from input\n    const inputContent =\n      typeof input === \"object\" && input !== null && \"content\" in input\n        ? input.content\n        : input;\n\n    const userSystemPrompt =\n      typeof input === \"object\" && input !== null && \"systemPrompt\" in input\n        ? input.systemPrompt\n        : undefined;\n\n    const messages: Message[] = [\n      {\n        type: \"text\",\n        role: \"system\",\n        content: userSystemPrompt\n          ? `${systemContent}\\n\\n${userSystemPrompt}`\n          : systemContent,\n      },\n    ];\n\n    if (inputContent.length > 0) {\n      messages.push({ type: \"text\", role: \"user\", content: inputContent });\n    }\n\n    if (this.assistant.length > 0) {\n      messages.push({\n        type: \"text\",\n        role: \"assistant\",\n        content: this.assistant,\n      });\n    }\n\n    return messages;\n  }\n\n  // initMCP fetches all tools from the agent's MCP servers, adding them to the tool list.\n  // This is all that's necessary in order to enable MCP tool use within agents\n  private async initMCP() {\n    if (!this.mcpServers || this._mcpClients.length >= this.mcpServers.length) {\n      return;\n    }\n\n    const promises = [];\n    for (const server of this.mcpServers) {\n      promises.push(this.listMCPTools(server));\n    }\n\n    await Promise.all(promises);\n  }\n\n  /**\n   * listMCPTools lists all available tools for a given MCP server\n   */\n  private async listMCPTools(server: MCP.Server) {\n    const { JSONSchemaToZod } = await import(\n      \"@dmitryrechkin/json-schema-to-zod\"\n    );\n    const client = await this.mcpClient(server);\n    this._mcpClients.push(client);\n    try {\n      const results = await client.request(\n        { method: \"tools/list\" },\n        ListToolsResultSchema\n      );\n      results.tools.forEach((t) => {\n        const name = `${server.name}-${t.name}`;\n\n        let zschema: undefined | ZodType;\n        try {\n          // The converter may return a Zod v3 schema type; coerce to v4 type or fallback\n          zschema = JSONSchemaToZod.convert(\n            t.inputSchema as JSONSchema\n          ) as unknown as ZodType;\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        } catch (e) {\n          // Do nothing here.\n          zschema = undefined;\n        }\n\n        // Add the MCP tools directly to the tool set.\n        this.tools.set(name, {\n          name: name,\n          description: t.description,\n          parameters: zschema,\n          mcp: {\n            server,\n            tool: t,\n          },\n          handler: async (input: { [x: string]: unknown } | undefined) => {\n            const fn = () =>\n              client.callTool({\n                name: t.name,\n                arguments: input,\n              });\n\n            const step = await getStepTools();\n            const result = await (step?.run(name, fn) ?? fn());\n\n            return result.content;\n          },\n        });\n      });\n    } catch (e) {\n      console.warn(\"error listing mcp tools\", e);\n    }\n  }\n\n  /**\n   * mcpClient creates a new MCP client for the given server.\n   */\n  private async mcpClient(server: MCP.Server): Promise<MCPClient> {\n    // Does this client already exist?\n    const transport: Transport = (() => {\n      switch (server.transport.type) {\n        case \"streamable-http\":\n          return new StreamableHTTPClientTransport(\n            new URL(server.transport.url),\n            {\n              requestInit: server.transport.requestInit,\n              authProvider: server.transport.authProvider,\n              reconnectionOptions: server.transport.reconnectionOptions,\n              sessionId: server.transport.sessionId,\n            }\n          );\n        case \"sse\":\n          // Check if EventSource is defined.  If not, we use a polyfill.\n          if (global.EventSource === undefined) {\n            global.EventSource = EventSource;\n          }\n          return new SSEClientTransport(new URL(server.transport.url), {\n            eventSourceInit: server.transport.eventSourceInit,\n            requestInit: server.transport.requestInit,\n          });\n        case \"ws\":\n          return new WebSocketClientTransport(new URL(server.transport.url));\n        case \"stdio\": {\n          const { command, args, env } = server.transport;\n          const safeProcessEnv = Object.fromEntries(\n            Object.entries(process.env).filter(([, v]) => v !== undefined)\n          ) as Record<string, string>;\n          const finalEnv = { ...safeProcessEnv, ...env };\n          return new StdioClientTransport({\n            command,\n            args,\n            env: finalEnv,\n          });\n        }\n      }\n    })();\n\n    const client = new MCPClient(\n      {\n        name: this.name,\n        // XXX: This version should change.\n        version: \"1.0.0\",\n      },\n      {\n        capabilities: {},\n      }\n    );\n    try {\n      await client.connect(transport);\n    } catch (e) {\n      // The transport closed.\n      console.warn(\"mcp server disconnected\", server, e);\n    }\n    return client;\n  }\n}\n\nexport class RoutingAgent<T extends StateData> extends Agent<T> {\n  type = \"routing\";\n  override lifecycles: Agent.RoutingLifecycle<T>;\n  constructor(opts: Agent.RoutingConstructor<T>) {\n    super(opts);\n    this.lifecycles = opts.lifecycle;\n  }\n\n  override withModel(model: AiAdapter.Any): RoutingAgent<T> {\n    return new RoutingAgent({\n      name: this.name,\n      description: this.description,\n      system: this.system,\n      assistant: this.assistant,\n      tools: Array.from(this.tools.values()),\n      lifecycle: this.lifecycles,\n      model,\n    });\n  }\n}\n\nexport namespace Agent {\n  export interface Constructor<T extends StateData> {\n    name: string;\n    description?: string;\n    system:\n      | string\n      | ((ctx: { network?: NetworkRun<T> }) => MaybePromise<string>);\n    assistant?: string;\n    tools?: (Tool.Any | InngestFunction.Any)[];\n    tool_choice?: Tool.Choice;\n    lifecycle?: Lifecycle<T>;\n    model?: AiAdapter.Any;\n    mcpServers?: MCP.Server[];\n    history?: HistoryConfig<T>;\n  }\n\n  export interface RoutingConstructor<T extends StateData>\n    extends Omit<Constructor<T>, \"lifecycle\"> {\n    lifecycle: RoutingLifecycle<T>;\n  }\n\n  export interface RoutingConstructor<T extends StateData>\n    extends Omit<Constructor<T>, \"lifecycle\"> {\n    lifecycle: RoutingLifecycle<T>;\n  }\n\n  export interface RoutingConstructor<T extends StateData>\n    extends Omit<Constructor<T>, \"lifecycle\"> {\n    lifecycle: RoutingLifecycle<T>;\n  }\n\n  export interface RunOptions<T extends StateData> {\n    model?: AiAdapter.Any;\n    network?: NetworkRun<T>;\n    /**\n     * State allows you to pass custom state into a single agent run call.  This should only\n     * be provided if you are running agents outside of a network.  Networks automatically\n     * supply their own state.\n     */\n    state?: State<T>;\n    maxIter?: number;\n    /**\n     * Streaming configuration for standalone agent runs. When provided, the agent will\n     * automatically emit streaming events throughout its execution. Note: this is ignored\n     * when the agent is run within a network, as networks control streaming.\n     */\n    streaming?: StreamingConfig;\n    // Internal: provided by Network to enable runtime streaming from agents\n    streamingContext?: StreamingContext;\n    // Internal: provided by Network to pass wrapped step tools for automatic step events\n    step?: GetStepTools<Inngest.Any>;\n  }\n\n  export interface Lifecycle<T extends StateData> {\n    /**\n     * enabled selectively enables or disables this agent based off of network\n     * state.  If this function is not provided, the agent is always enabled.\n     */\n    enabled?: (args: Agent.LifecycleArgs.Base<T>) => MaybePromise<boolean>;\n\n    /**\n     * onStart is called just before an agent starts an inference call.\n     *\n     * This receives the full agent prompt.  If this is a networked agent, the\n     * agent will also receive the network's history which will be concatenated\n     * to the end of the prompt when making the inference request.\n     *\n     * The return values can be used to adjust the prompt, history, or to stop\n     * the agent from making the call altogether.\n     *\n     */\n    onStart?: (args: Agent.LifecycleArgs.Before<T>) => MaybePromise<{\n      prompt: Message[];\n      history: Message[];\n      // stop, if true, will prevent calling the agent\n      stop: boolean;\n    }>;\n\n    /**\n     * onResponse is called after the inference call finishes, before any tools\n     * have been invoked. This allows you to moderate the response prior to\n     * running tools.\n     */\n    onResponse?: (\n      args: Agent.LifecycleArgs.Result<T>\n    ) => MaybePromise<AgentResult>;\n\n    /**\n     * onFinish is called with a finalized AgentResult, including any tool\n     * call results. The returned AgentResult will be saved to network\n     * history, if the agent is part of the network.\n     *\n     */\n    onFinish?: (\n      args: Agent.LifecycleArgs.Result<T>\n    ) => MaybePromise<AgentResult>;\n  }\n\n  export namespace LifecycleArgs {\n    export interface Base<T extends StateData> {\n      // Agent is the agent that made the call.\n      agent: Agent<T>;\n      // Network represents the network that this agent or lifecycle belongs to.\n      network?: NetworkRun<T>;\n    }\n\n    export interface Result<T extends StateData> extends Base<T> {\n      result: AgentResult;\n    }\n\n    export interface Before<T extends StateData> extends Base<T> {\n      // input is the user request for the entire agentic operation.\n      input?: string;\n\n      // prompt is the system, user, and any assistant prompt as generated\n      // by the Agent.  This does not include any past history.\n      prompt: Message[];\n\n      // history is the past history as generated via State.  Ths will be added\n      // after the prompt to form a single conversation log.\n      history?: Message[];\n    }\n  }\n\n  export interface RoutingLifecycle<T extends StateData> extends Lifecycle<T> {\n    onRoute: RouterFn<T>;\n  }\n\n  export type RouterFn<T extends StateData> = (\n    args: Agent.RouterArgs<T>\n  ) => string[] | undefined;\n\n  /**\n   * Router args are the arguments passed to the onRoute lifecycle hook.\n   */\n  export type RouterArgs<T extends StateData> = Agent.LifecycleArgs.Result<T>;\n}\n","import { type AiAdapter } from \"@inngest/ai\";\nimport { adapters } from \"./adapters\";\nimport { type Message } from \"./types\";\nimport { type Tool } from \"./tool\";\nimport { getStepTools } from \"./util\";\n\nexport const createAgenticModelFromAiAdapter = <\n  TAiAdapter extends AiAdapter.Any,\n>(\n  adapter: TAiAdapter\n): AgenticModel<TAiAdapter> => {\n  const opts = adapters[adapter.format as AiAdapter.Format];\n\n  return new AgenticModel({\n    model: adapter,\n    requestParser:\n      opts.request as unknown as AgenticModel.RequestParser<TAiAdapter>,\n    responseParser:\n      opts.response as unknown as AgenticModel.ResponseParser<TAiAdapter>,\n  });\n};\n\nexport class AgenticModel<TAiAdapter extends AiAdapter.Any> {\n  #model: TAiAdapter;\n  requestParser: AgenticModel.RequestParser<TAiAdapter>;\n  responseParser: AgenticModel.ResponseParser<TAiAdapter>;\n\n  constructor({\n    model,\n    requestParser,\n    responseParser,\n  }: AgenticModel.Constructor<TAiAdapter>) {\n    this.#model = model;\n    this.requestParser = requestParser;\n    this.responseParser = responseParser;\n  }\n\n  async infer(\n    stepID: string,\n    input: Message[],\n    tools: Tool.Any[],\n    tool_choice: Tool.Choice\n  ): Promise<AgenticModel.InferenceResponse> {\n    // TODO: Implement true token-by-token streaming from LLM providers\n    // Currently using completed response chunking for streaming simulation\n    // Future enhancement: Process real-time token streams from OpenAI/Anthropic/etc.\n    const body = this.requestParser(this.#model, input, tools, tool_choice);\n    let result: AiAdapter.Input<TAiAdapter>;\n\n    const step = await getStepTools();\n\n    if (step) {\n      result = (await step.ai.infer(stepID, {\n        model: this.#model,\n        body,\n      })) as AiAdapter.Input<TAiAdapter>;\n    } else {\n      // Allow the model to mutate options and body for this call\n      const modelCopy = { ...this.#model };\n      this.#model.onCall?.(modelCopy, body);\n\n      const url = new URL(modelCopy.url || \"\");\n\n      const headers: Record<string, string> = {\n        \"Content-Type\": \"application/json\",\n      };\n\n      // Make sure we handle every known format in `@inngest/ai`.\n      const formatHandlers: Record<AiAdapter.Format, () => void> = {\n        \"openai-chat\": () => {\n          headers[\"Authorization\"] = `Bearer ${modelCopy.authKey}`;\n        },\n        \"azure-openai\": () => {\n          headers[\"api-key\"] = modelCopy.authKey;\n        },\n        anthropic: () => {\n          headers[\"x-api-key\"] = modelCopy.authKey;\n          headers[\"anthropic-version\"] = \"2023-06-01\";\n        },\n        gemini: () => {},\n        grok: () => {},\n      };\n\n      formatHandlers[modelCopy.format as AiAdapter.Format]();\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      result = await (\n        await fetch(url, {\n          method: \"POST\",\n          headers,\n          body: JSON.stringify(body),\n        })\n      ).json();\n    }\n\n    return { output: this.responseParser(result), raw: result };\n  }\n}\n\nexport namespace AgenticModel {\n  export type Any = AgenticModel<AiAdapter.Any>;\n\n  /**\n   * InferenceResponse is the response from a model for an inference request.\n   * This contains parsed messages and the raw result, with the type of the raw\n   * result depending on the model's API repsonse.\n   */\n  export type InferenceResponse<T = unknown> = {\n    output: Message[];\n    raw: T;\n  };\n\n  export interface Constructor<TAiAdapter extends AiAdapter.Any> {\n    model: TAiAdapter;\n    requestParser: RequestParser<TAiAdapter>;\n    responseParser: ResponseParser<TAiAdapter>;\n  }\n\n  export type RequestParser<TAiAdapter extends AiAdapter.Any> = (\n    model: TAiAdapter,\n    state: Message[],\n    tools: Tool.Any[],\n    tool_choice: Tool.Choice\n  ) => AiAdapter.Input<TAiAdapter>;\n\n  export type ResponseParser<TAiAdapter extends AiAdapter.Any> = (\n    output: AiAdapter.Output<TAiAdapter>\n  ) => Message[];\n}\n","import { type AiAdapter, type AiAdapters } from \"@inngest/ai\";\nimport { type AgenticModel } from \"../model\";\nimport * as anthropic from \"./anthropic\";\nimport * as openai from \"./openai\";\nimport * as azureOpenai from \"./azure-openai\";\nimport * as gemini from \"./gemini\";\nimport * as grok from \"./grok\";\n\nexport type Adapters = {\n  [Format in AiAdapter.Format]: {\n    request: AgenticModel.RequestParser<AiAdapters[Format]>;\n    response: AgenticModel.ResponseParser<AiAdapters[Format]>;\n  };\n};\n\nexport const adapters: Adapters = {\n  \"openai-chat\": {\n    request: openai.requestParser,\n    response: openai.responseParser,\n  },\n  \"azure-openai\": {\n    request: azureOpenai.requestParser,\n    response: azureOpenai.responseParser,\n  },\n  anthropic: {\n    request: anthropic.requestParser,\n    response: anthropic.responseParser,\n  },\n  gemini: {\n    request: gemini.requestParser,\n    response: gemini.responseParser,\n  },\n  grok: {\n    request: grok.requestParser,\n    response: grok.responseParser,\n  },\n};\n","/**\n * Adapters for Anthropic I/O to transform to/from internal network messages.\n *\n * @module\n */\nimport {\n  type AiAdapter,\n  type Anthropic,\n  type AnthropicAiAdapter,\n} from \"@inngest/ai\";\nimport { z } from \"zod\";\nimport { type AgenticModel } from \"../model\";\nimport { type Message, type TextMessage } from \"../types\";\nimport { type Tool } from \"../tool\";\n\n/**\n * Parse a request from internal network messages to an Anthropic input.\n */\nexport const requestParser: AgenticModel.RequestParser<Anthropic.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  // Note that Anthropic has a top-level system prompt, then a series of prompts\n  // for assistants and users.\n  const systemMessage = messages.find(\n    (m: Message) => m.role === \"system\" && m.type === \"text\"\n  ) as TextMessage;\n  const system =\n    typeof systemMessage?.content === \"string\" ? systemMessage.content : \"\";\n\n  const anthropicMessages: AiAdapter.Input<Anthropic.AiModel>[\"messages\"] =\n    messages\n      .filter((m: Message) => m.role !== \"system\")\n      .reduce(\n        (\n          acc: AiAdapter.Input<Anthropic.AiModel>[\"messages\"],\n          m: Message\n        ): AiAdapter.Input<Anthropic.AiModel>[\"messages\"] => {\n          switch (m.type) {\n            case \"text\":\n              return [\n                ...acc,\n                {\n                  role: m.role,\n                  content: Array.isArray(m.content)\n                    ? m.content.map((text) => ({ type: \"text\", text }))\n                    : m.content,\n                },\n              ] as AiAdapter.Input<Anthropic.AiModel>[\"messages\"];\n            case \"tool_call\":\n              return [\n                ...acc,\n                {\n                  role: m.role,\n                  content: m.tools.map((tool) => ({\n                    type: \"tool_use\",\n                    id: tool.id,\n                    input: tool.input,\n                    name: tool.name,\n                  })),\n                },\n              ];\n            case \"tool_result\":\n              return [\n                ...acc,\n                {\n                  role: \"user\",\n                  content: [\n                    {\n                      type: \"tool_result\",\n                      tool_use_id: m.tool.id,\n                      content:\n                        typeof m.content === \"string\"\n                          ? m.content\n                          : JSON.stringify(m.content),\n                    },\n                  ],\n                },\n              ];\n          }\n        },\n        [] as AiAdapter.Input<Anthropic.AiModel>[\"messages\"]\n      );\n\n  // We need to patch the last message if it's an assistant message.  This is a known limitation of Anthropic's API.\n  // cf: https://github.com/langchain-ai/langgraph/discussions/952#discussioncomment-10012320\n  const lastMessage = anthropicMessages[anthropicMessages.length - 1];\n  if (lastMessage?.role === \"assistant\") {\n    lastMessage.role = \"user\";\n  }\n\n  const request: AiAdapter.Input<Anthropic.AiModel> = {\n    system,\n    model: model.options.model,\n    max_tokens: model.options.defaultParameters.max_tokens,\n    messages: anthropicMessages,\n  };\n\n  if (tools?.length) {\n    request.tools = tools.map((t: Tool.Any) => {\n      return {\n        name: t.name,\n        description: t.description,\n        input_schema: (t.parameters\n          ? z.toJSONSchema(t.parameters, {\n              target: \"draft-2020-12\",\n            })\n          : z.toJSONSchema(z.object({}), {\n              target: \"draft-2020-12\",\n            })) as AnthropicAiAdapter.Tool.InputSchema,\n      };\n    });\n    request.tool_choice = toolChoice(tool_choice);\n  }\n\n  return request;\n};\n\n/**\n * Parse a response from Anthropic output to internal network messages.\n */\nexport const responseParser: AgenticModel.ResponseParser<Anthropic.AiModel> = (\n  input\n) => {\n  if (input.type === \"error\") {\n    throw new Error(\n      input.error?.message ||\n        `Anthropic request failed: ${JSON.stringify(input.error)}`\n    );\n  }\n\n  return (input?.content ?? []).reduce<Message[]>((acc, item) => {\n    if (!item.type) {\n      return acc;\n    }\n\n    switch (item.type) {\n      case \"text\":\n        return [\n          ...acc,\n          {\n            type: \"text\",\n            role: input.role,\n            content: item.text,\n            // XXX: Better stop reason parsing\n            stop_reason: \"stop\",\n          },\n        ];\n      case \"tool_use\": {\n        let args;\n        try {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n          args =\n            typeof item.input === \"string\"\n              ? JSON.parse(item.input)\n              : item.input;\n        } catch {\n          args = item.input;\n        }\n\n        return [\n          ...acc,\n          {\n            type: \"tool_call\",\n            role: input.role,\n            stop_reason: \"tool\",\n            tools: [\n              {\n                type: \"tool\",\n                id: item.id,\n                name: item.name,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                input: args,\n              },\n            ],\n          },\n        ];\n      }\n    }\n  }, []);\n};\n\nconst toolChoice = (\n  choice: Tool.Choice\n): AiAdapter.Input<Anthropic.AiModel>[\"tool_choice\"] => {\n  switch (choice) {\n    case \"auto\":\n      return { type: \"auto\" };\n    case \"any\":\n      return { type: \"any\" };\n    default:\n      if (typeof choice === \"string\") {\n        return {\n          type: \"tool\",\n          name: choice as string,\n        };\n      }\n  }\n};\n","import { type GetStepTools, type Inngest } from \"inngest\";\nimport { type output as ZodOutput } from \"zod\";\nimport { type Agent } from \"./agent\";\nimport { type StateData } from \"./state\";\nimport { type NetworkRun } from \"./network\";\nimport { type AnyZodType, type MaybePromise } from \"./util\";\nimport type { StreamableHTTPReconnectionOptions } from \"@modelcontextprotocol/sdk/client/streamableHttp.js\";\nimport type { OAuthClientProvider } from \"@modelcontextprotocol/sdk/client/auth.js\";\n\n/**\n * ToolResultPayload mirrors the UI package shape for structured tool outputs.\n */\nexport type ToolResultPayload<T> = { data: T };\n\n/**\n * createTool is a helper that properly types the input argument for a handler\n * based off of the Zod parameter types, and captures the handler output type.\n */\nexport function createTool<\n  TName extends string,\n  TInput extends Tool.Input,\n  TOutput,\n  TState extends StateData,\n>({\n  name,\n  description,\n  parameters,\n  handler,\n}: {\n  name: TName;\n  description?: string;\n  parameters?: TInput;\n  handler: (\n    input: ZodOutput<TInput>,\n    opts: Tool.Options<TState>\n  ) => MaybePromise<TOutput>;\n}): Tool<TName, TInput, TOutput> {\n  return {\n    name,\n    description,\n    parameters,\n    handler<TS extends StateData>(\n      input: ZodOutput<TInput>,\n      opts: Tool.Options<TS>\n    ): MaybePromise<TOutput> {\n      return handler(input, opts as unknown as Tool.Options<TState>);\n    },\n  };\n}\n\nexport type Tool<TName extends string, TInput extends Tool.Input, TOutput> = {\n  name: TName;\n  description?: string;\n  parameters?: TInput;\n\n  // mcp lists the MCP details for this tool, if this tool is provided by an\n  // MCP server.\n  mcp?: {\n    server: MCP.Server;\n    tool: MCP.Tool;\n  };\n\n  strict?: boolean;\n\n  handler<TState extends StateData>(\n    input: ZodOutput<TInput>,\n    opts: Tool.Options<TState>\n  ): MaybePromise<TOutput>;\n};\n\nexport namespace Tool {\n  export type Any = Tool<string, Tool.Input, unknown>;\n\n  export type Options<T extends StateData> = {\n    agent: Agent<T>;\n    network: NetworkRun<T>;\n    step?: GetStepTools<Inngest.Any>;\n  };\n\n  export type Input = AnyZodType;\n\n  export type Choice = \"auto\" | \"any\" | (string & {});\n}\n\n/**\n * Helper to create a strongly-typed tool manifest from a list of tools.\n *\n * Returns a simple runtime object keyed by tool name. The primary value is the\n * compile-time type that captures each tool's input and output types.\n */\nexport function createToolManifest<\n  TTools extends readonly Tool<string, Tool.Input, unknown>[],\n>(tools: TTools) {\n  const manifest: Record<string, { input: unknown; output: unknown }> = {};\n  for (const t of tools) {\n    // runtime structure is intentionally minimal; types carry the value\n    manifest[t.name] = { input: {}, output: {} };\n  }\n  type Result = {\n    [K in TTools[number] as K[\"name\"] & string]: K extends Tool<\n      string,\n      infer In extends AnyZodType,\n      infer Out\n    >\n      ? { input: ZodOutput<In>; output: ToolResultPayload<Out> }\n      : never;\n  };\n  return manifest as Result;\n}\n\nexport namespace MCP {\n  export type Server = {\n    // name is a short name for the MCP server, eg. \"github\".  This allows\n    // us to namespace tools for each MCP server.\n    name: string;\n    transport:\n      | TransportSSE\n      | TransportWebsocket\n      | TransportStreamableHttp\n      | TransportStdio;\n  };\n\n  export type Transport =\n    | TransportSSE\n    | TransportWebsocket\n    | TransportStreamableHttp\n    | TransportStdio;\n\n  export type TransportStreamableHttp = {\n    type: \"streamable-http\";\n    url: string;\n    requestInit?: RequestInit;\n    reconnectionOptions?: StreamableHTTPReconnectionOptions;\n    sessionId?: string;\n    authProvider?: OAuthClientProvider;\n  };\n\n  export type TransportStdio = {\n    type: \"stdio\";\n    command: string;\n    args: string[];\n    env?: Record<string, string>;\n  };\n\n  export type TransportSSE = {\n    type: \"sse\";\n    url: string;\n    eventSourceInit?: EventSourceInit;\n    requestInit?: RequestInit;\n  };\n\n  export type TransportWebsocket = {\n    type: \"ws\";\n    url: string;\n  };\n\n  export type Tool = {\n    name: string;\n    description?: string;\n    inputSchema?: {\n      type: \"object\";\n      properties?: unknown;\n    };\n  };\n}\n","/**\n * Adapters for OpenAI I/O to transform to/from internal network messages.\n *\n * @module\n */\n\nimport { type AiAdapter, type OpenAi } from \"@inngest/ai\";\nimport { z } from \"zod\";\nimport { type AgenticModel } from \"../model\";\nimport {\n  type Message,\n  type TextMessage,\n  type ToolCallMessage,\n  type ToolMessage,\n} from \"../types\";\nimport { type Tool } from \"../tool\";\nimport { stringifyError } from \"../util\";\n\n/**\n * Parse a request from internal network messages to an OpenAI input.\n */\nexport const requestParser: AgenticModel.RequestParser<OpenAi.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  const request: AiAdapter.Input<OpenAi.AiModel> = {\n    messages: messages.map((m: Message) => {\n      switch (m.type) {\n        case \"text\":\n          return {\n            role: m.role,\n            content: m.content,\n          };\n        case \"tool_call\":\n          return {\n            role: \"assistant\",\n            content: null,\n            tool_calls: m.tools\n              ? m.tools?.map((tool) => ({\n                  id: tool.id,\n                  type: \"function\",\n                  function: {\n                    name: tool.name,\n                    arguments: JSON.stringify(tool.input),\n                  },\n                }))\n              : undefined,\n          };\n        case \"tool_result\":\n          return {\n            role: \"tool\",\n            tool_call_id: m.tool.id,\n            content:\n              typeof m.content === \"string\"\n                ? m.content\n                : JSON.stringify(m.content),\n          };\n      }\n    }) as AiAdapter.Input<OpenAi.AiModel>[\"messages\"],\n  };\n\n  if (tools?.length) {\n    request.tool_choice = toolChoice(tool_choice);\n    // OpenAI o3 models have several issues with tool calling.\n    //  one of them is not supporting the `parallel_tool_calls` parameter\n    //  https://community.openai.com/t/o3-mini-api-with-tools-only-ever-returns-1-tool-no-matter-prompt/1112390/6\n    if (\n      !model.options.model?.includes(\"o3\") &&\n      !model.options.model?.includes(\"o1\")\n    ) {\n      // it is recommended to disable parallel tool calls with structured output\n      // https://platform.openai.com/docs/guides/function-calling#parallel-function-calling-and-structured-outputs\n      request.parallel_tool_calls = false;\n    }\n\n    request.tools = tools.map((t: Tool.Any) => {\n      return {\n        type: \"function\",\n        function: {\n          name: t.name,\n          description: t.description,\n          parameters:\n            t.parameters && z.toJSONSchema(t.parameters, { target: \"draft-7\" }),\n          strict:\n            typeof t.strict !== \"undefined\" ? t.strict : Boolean(t.parameters), // strict mode is only supported with parameters\n        },\n      };\n    });\n  }\n\n  return request;\n};\n\n/**\n * Parse a response from OpenAI output to internal network messages.\n *\n * This function transforms OpenAI's response format into our internal Message format,\n * handling both text responses and tool calls. It processes multiple choices if present\n * and creates separate messages for text content and tool calls when both exist.\n */\nexport const responseParser: AgenticModel.ResponseParser<OpenAi.AiModel> = (\n  input\n) => {\n  // Handle API errors first - throw immediately if the request failed\n  if (input.error) {\n    throw new Error(\n      input.error.message ||\n        `OpenAI request failed: ${JSON.stringify(input.error)}`\n    );\n  }\n\n  // Process all choices from the OpenAI response using reduce to flatten into a single Message array\n  // OpenAI can return multiple choices, though typically only one is returned\n  return (input?.choices ?? []).reduce<Message[]>((acc, choice) => {\n    const { message, finish_reason } = choice;\n\n    // Skip empty messages - can happen in some edge cases\n    if (!message) {\n      return acc;\n    }\n\n    // Create base message properties shared by all message types\n    // Maps OpenAI's finish_reason to our internal stop_reason format\n    const base = {\n      role: choice.message.role,\n      stop_reason:\n        openAiStopReasonToStateStopReason[finish_reason ?? \"\"] || \"stop\",\n    };\n\n    // Handle text content - only create a text message if content exists and isn't empty/whitespace\n    // This check prevents empty content messages that can occur when only tool calls are present\n    if (message.content && message.content.trim() !== \"\") {\n      acc.push({\n        ...base,\n        type: \"text\",\n        content: message.content,\n      } as TextMessage);\n    }\n\n    // Handle tool calls - create a separate tool_call message containing all tools\n    // OpenAI can return multiple tool calls in a single response (parallel tool calling)\n    if ((message.tool_calls?.length ?? 0) > 0) {\n      acc.push({\n        ...base,\n        type: \"tool_call\",\n        tools: message.tool_calls.map((tool) => {\n          return {\n            type: \"tool\",\n            id: tool.id,\n            name: tool.function.name,\n            function: tool.function.name, // Duplicate for backward compatibility\n            // Use safe parser to handle OpenAI's JSON quirks (like backticks in strings)\n            input: safeParseOpenAIJson(tool.function.arguments || \"{}\"),\n          } as ToolMessage;\n        }),\n      } as ToolCallMessage);\n    }\n\n    return acc;\n  }, []);\n};\n\n/**\n * Parse the given `str` `string` as JSON, also handling backticks, a common\n * OpenAI quirk.\n *\n * @example Input\n * ```\n * \"{\\n  \\\"files\\\": [\\n    {\\n      \\\"filename\\\": \\\"fibo.ts\\\",\\n      \\\"content\\\": `\\nfunction fibonacci(n: number): number {\\n  if (n < 2) {\\n    return n;\\n  } else {\\n    return fibonacci(n - 1) + fibonacci(n - 2);\\n  }\\n}\\n\\nexport default fibonacci;\\n`\\n    }\\n  ]\\n}\"\n * ```\n */\nconst safeParseOpenAIJson = (str: string): unknown => {\n  // Remove any leading/trailing quotes if present\n  const trimmed = str.replace(/^[\"']|[\"']$/g, \"\");\n\n  try {\n    // First try direct JSON parse\n    return JSON.parse(trimmed);\n  } catch {\n    try {\n      // Replace backtick strings with regular JSON strings\n      // Match content between backticks, preserving newlines\n      const withQuotes = trimmed.replace(/`([\\s\\S]*?)`/g, (_, content) =>\n        JSON.stringify(content)\n      );\n      return JSON.parse(withQuotes);\n    } catch (e) {\n      throw new Error(\n        `Failed to parse JSON with backticks: ${stringifyError(e)}`\n      );\n    }\n  }\n};\n\nconst openAiStopReasonToStateStopReason: Record<string, string> = {\n  tool_calls: \"tool\",\n  stop: \"stop\",\n  length: \"stop\",\n  content_filter: \"stop\",\n  function_call: \"tool\",\n};\n\nconst toolChoice = (choice: Tool.Choice) => {\n  switch (choice) {\n    case \"auto\":\n      return \"auto\";\n    case \"any\":\n      return \"required\";\n    default:\n      return {\n        type: \"function\" as const,\n        function: { name: choice as string },\n      };\n  }\n};\n","import { type AiAdapter, type AzureOpenAi, type OpenAi } from \"@inngest/ai\";\nimport { type AgenticModel } from \"../model\";\nimport {\n  requestParser as openaiRequestParser,\n  responseParser as openaiResponseParser,\n} from \"./openai\";\n\nexport const requestParser: AgenticModel.RequestParser<AzureOpenAi.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) =>\n  openaiRequestParser(\n    model as unknown as OpenAi.AiModel,\n    messages,\n    tools,\n    tool_choice\n  );\n\nexport const responseParser: AgenticModel.ResponseParser<\n  AzureOpenAi.AiModel\n> = (output) =>\n  openaiResponseParser(output as unknown as AiAdapter.Output<OpenAi.AiModel>);\n","/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/* eslint-disable @typescript-eslint/no-unsafe-assignment */\n/**\n * Adapters for Gemini I/O to transform to/from internal network messages.\n *\n * @module\n */\nimport { type AiAdapter, type Gemini } from \"@inngest/ai\";\nimport { z, type ZodSchema } from \"zod\";\n\nimport { type AgenticModel } from \"../model\";\nimport type { Message, TextContent } from \"../types\";\nimport { type Tool } from \"../tool\";\n\n/**\n * Parse a request from internal network messages to an Gemini input.\n */\nexport const requestParser: AgenticModel.RequestParser<Gemini.AiModel> = (\n  _model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  const contents = messages.map((m: Message) => messageToContent(m));\n\n  const functionDeclarations = tools.map((t: Tool.Any) => ({\n    name: t.name,\n    description: t.description,\n    parameters: t.parameters\n      ? geminiZodToJsonSchema(t.parameters)\n      : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (geminiZodToJsonSchema(z.object({})) as any),\n  }));\n\n  return {\n    contents,\n    ...(tools.length > 0\n      ? {\n          tools: [\n            {\n              functionDeclarations,\n            },\n          ],\n          tool_config: toolChoice(tool_choice),\n        }\n      : {}),\n  };\n};\n\nconst messageContentToString = (content: string | TextContent[]): string => {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  return content.map((c) => c.text).join(\"\");\n};\n\n/**\n * Parse a response from Gemini output to internal network messages.\n */\nexport const responseParser: AgenticModel.ResponseParser<Gemini.AiModel> = (\n  input\n) => {\n  if (input.error) {\n    throw new Error(\n      input.error?.message ||\n        `Gemini request failed: ${JSON.stringify(input.error)}`\n    );\n  }\n\n  const messages: Message[] = [];\n\n  for (const candidate of input.candidates ?? []) {\n    if ((candidate.finishReason as string) === \"MALFORMED_FUNCTION_CALL\") {\n      console.warn(\n        \"Gemini returned MALFORMED_FUNCTION_CALL, skipping this candidate. This typically indicates an issue with tool/function call formatting. Check your tool definitions and parameters.\"\n      );\n      continue; // Skip this candidate but continue processing others\n    }\n    if (!candidate.content?.parts) {\n      continue; // Skip candidates without parts\n    }\n    for (const content of candidate.content.parts) {\n      // user text\n      if (candidate.content.role === \"user\" && \"text\" in content) {\n        messages.push({\n          role: \"user\",\n          type: \"text\",\n          content: content.text,\n        });\n      }\n      // assistant text\n      else if (candidate.content.role === \"model\" && \"text\" in content) {\n        messages.push({\n          role: \"assistant\",\n          type: \"text\",\n          content: content.text,\n        });\n      }\n      // tool call\n      else if (\n        candidate.content.role === \"model\" &&\n        \"functionCall\" in content\n      ) {\n        messages.push({\n          role: \"assistant\",\n          type: \"tool_call\",\n          stop_reason: \"tool\",\n          tools: [\n            {\n              name: content.functionCall.name,\n              input: content.functionCall.args,\n              type: \"tool\",\n              id: content.functionCall.name,\n            },\n          ],\n        });\n      }\n      // tool result\n      else if (\n        candidate.content.role === \"user\" &&\n        \"functionResponse\" in content\n      ) {\n        messages.push({\n          role: \"tool_result\",\n          type: \"tool_result\",\n          stop_reason: \"tool\",\n          tool: {\n            name: content.functionResponse.name,\n            input: content.functionResponse.response,\n            type: \"tool\",\n            id: content.functionResponse.name,\n          },\n          content: JSON.stringify(content.functionResponse.response),\n        });\n      } else {\n        throw new Error(\"Unknown content type\");\n      }\n    }\n  }\n\n  return messages;\n};\n\nconst messageToContent = (\n  m: Message\n): AiAdapter.Input<Gemini.AiModel>[\"contents\"][0] => {\n  switch (m.role) {\n    case \"system\":\n      return {\n        role: \"user\",\n        parts: [{ text: messageContentToString(m.content) }],\n      };\n    case \"user\":\n      switch (m.type) {\n        case \"tool_call\":\n          if (m.tools.length === 0) {\n            throw new Error(\"Tool call message must have at least one tool\");\n          }\n          // Note: multiple tools is only supported over WS (Compositional function calling)\n          return {\n            role: \"model\",\n            parts: [\n              {\n                functionCall: {\n                  name: m.tools[0]!.name,\n                  args: m.tools[0]!.input,\n                },\n              },\n            ],\n          };\n        case \"text\":\n        default:\n          return {\n            role: \"user\",\n            parts: [{ text: messageContentToString(m.content) }],\n          };\n      }\n    case \"assistant\":\n      switch (m.type) {\n        case \"tool_call\":\n          if (m.tools.length === 0) {\n            throw new Error(\"Tool call message must have at least one tool\");\n          }\n          // Note: multiple tools is only supported over WS (Compositional function calling)\n          return {\n            role: \"model\",\n            parts: [\n              {\n                functionCall: {\n                  name: m.tools[0]!.name,\n                  args: m.tools[0]!.input,\n                },\n              },\n            ],\n          };\n        case \"text\":\n        default:\n          return {\n            role: \"model\",\n            parts: [{ text: messageContentToString(m.content) }],\n          };\n      }\n    case \"tool_result\":\n      return {\n        role: \"user\",\n        parts: [\n          {\n            functionResponse: {\n              name: m.tool.name,\n              response: {\n                name: m.tool.name,\n                content:\n                  typeof m.content === \"string\"\n                    ? m.content\n                    : JSON.stringify(m.content),\n              },\n            },\n          },\n        ],\n      };\n    default:\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      throw new Error(`Unknown message role: ${(m as any).role}`);\n  }\n};\n\nconst toolChoice = (\n  choice: Tool.Choice\n): AiAdapter.Input<Gemini.AiModel>[\"toolConfig\"] => {\n  switch (choice) {\n    case \"auto\":\n      return {\n        functionCallingConfig: {\n          mode: \"AUTO\",\n        },\n      };\n    case \"any\":\n      return {\n        functionCallingConfig: {\n          mode: \"ANY\",\n        },\n      };\n    default:\n      if (typeof choice === \"string\") {\n        return {\n          functionCallingConfig: {\n            mode: \"ANY\",\n            allowedFunctionNames: [choice],\n          },\n        };\n      }\n  }\n};\n\ntype Removed<T, Drop = \"additionalProperties\"> = T extends object\n  ? { [K in Exclude<keyof T, Drop>]: Removed<T[K], Drop> }\n  : T;\n\n/**\n * Recursively remove `additionalProperties` from Zod schema objects.\n */\nexport const recursiveGeminiZodToJsonSchema = <T>(obj: T): Removed<T> => {\n  if (obj === null || obj === undefined || typeof obj !== \"object\") {\n    return obj as Removed<T>;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(recursiveGeminiZodToJsonSchema) as unknown as Removed<T>;\n  }\n  const newObj: T = { ...obj }; // Create a shallow copy for the current level\n\n  for (const key in newObj) {\n    if (newObj[key] != null) {\n      newObj[key] = recursiveGeminiZodToJsonSchema(\n        newObj[key]\n      ) as T[typeof key];\n    }\n  }\n  if (newObj?.[\"additionalProperties\" as keyof typeof newObj] != null) {\n    delete newObj[\"additionalProperties\" as keyof typeof newObj];\n  }\n  return newObj as Removed<T>;\n};\n\nconst geminiZodToJsonSchema = (schemaIn: ZodSchema) => {\n  let schema = z.toJSONSchema(schemaIn, { target: \"openapi-3.0\", io: \"input\" });\n  schema = recursiveGeminiZodToJsonSchema(schema);\n  return schema;\n};\n","/**\n * Adapters for Grok I/O to transform to/from internal network messages.\n * Grok is an exotic one, it is an OpenAI-compatible API,\n * but does not support strict mode Function Calling, requiring an adapter.\n *\n * @module\n */\n\nimport type { AiAdapter, Grok, OpenAi } from \"inngest\";\nimport type { AgenticModel } from \"../model\";\nimport {\n  requestParser as openaiRequestParser,\n  responseParser as openaiResponseParser,\n} from \"./openai\";\n\n/**\n * Parse a request from internal network messages to an OpenAI input.\n */\nexport const requestParser: AgenticModel.RequestParser<Grok.AiModel> = (\n  model,\n  messages,\n  tools,\n  tool_choice = \"auto\"\n) => {\n  const request: AiAdapter.Input<Grok.AiModel> = openaiRequestParser(\n    model as unknown as OpenAi.AiModel,\n    messages,\n    tools,\n    tool_choice\n  );\n\n  // Grok does not support strict mode Function Calling, so we need to disable it\n  request.tools = (request.tools || []).map((tool) => ({\n    ...tool,\n    function: {\n      ...tool.function,\n      strict: false,\n    },\n  }));\n\n  return request;\n};\n\n/**\n * Parse a response from OpenAI output to internal network messages.\n */\nexport const responseParser: AgenticModel.ResponseParser<Grok.AiModel> =\n  openaiResponseParser as unknown as AgenticModel.ResponseParser<Grok.AiModel>;\n","/**\n * AgentKit Streaming System\n *\n * This module provides automatic event streaming capabilities for AgentKit networks and agents.\n * It defines the event schema that matches the useAgent hook expectations and provides\n * streaming context management for transparent event publishing.\n */\n\nimport { type Inngest } from \"inngest\";\nimport { type GetStepTools } from \"inngest\";\nimport { type State, type StateData } from \"./state\";\nimport { z } from \"zod\";\n\n/**\n * Base interface for all streaming events\n */\nexport interface AgentMessageChunk {\n  /** The event name (e.g., \"run.started\", \"part.created\") */\n  event: string;\n  /** Event-specific data payload */\n  data: Record<string, unknown>;\n  /** When the event occurred (Unix timestamp) */\n  timestamp: number;\n  /** Monotonic sequence number for ordering events */\n  sequenceNumber: number;\n  /** Suggested Inngest step ID for optional developer use */\n  id: string;\n}\n\n/**\n * Canonical runtime schema for AgentKit streaming events.\n * Matches the AgentMessageChunk interface above.\n */\nexport const AgentMessageChunkSchema = z.object({\n  event: z.string(),\n  data: z.record(z.string(), z.any()),\n  timestamp: z.number(),\n  sequenceNumber: z.number(),\n  id: z.string(),\n});\n\n// =============================================================================\n// RUN LIFECYCLE EVENTS\n// =============================================================================\n\nexport interface RunStartedEvent extends AgentMessageChunk {\n  event: \"run.started\";\n  data: {\n    runId: string; // Unique identifier for this run\n    parentRunId?: string; // If this is a nested run (e.g., agent within network)\n    scope: \"network\" | \"agent\"; // Level of execution\n    name: string; // Name of the network or agent\n    messageId?: string; // Optional message context\n    threadId?: string; // Thread context\n    metadata?: Record<string, unknown>; // Additional context\n  };\n}\n\nexport interface RunCompletedEvent extends AgentMessageChunk {\n  event: \"run.completed\";\n  data: {\n    runId: string;\n    scope: \"network\" | \"agent\";\n    name: string;\n    messageId?: string; // Optional message context\n    result?: unknown; // Final result from the run\n    usage?: {\n      promptTokens: number;\n      completionTokens: number;\n      totalTokens: number;\n      thinkingTokens?: number; // For models with reasoning\n    };\n  };\n}\n\nexport interface RunFailedEvent extends AgentMessageChunk {\n  event: \"run.failed\";\n  data: {\n    runId: string;\n    scope: \"network\" | \"agent\";\n    name: string;\n    messageId?: string; // Optional message context\n    error: string;\n    recoverable: boolean;\n    metadata?: Record<string, unknown>;\n  };\n}\n\nexport interface RunInterruptedEvent extends AgentMessageChunk {\n  event: \"run.interrupted\";\n  data: {\n    runId: string;\n    scope: \"network\" | \"agent\";\n    name: string;\n    reason: \"max_tokens\" | \"user_cancellation\" | \"timeout\" | \"other\";\n    metadata?: Record<string, unknown>;\n  };\n}\n\n// =============================================================================\n// STEP LIFECYCLE EVENTS\n// =============================================================================\n\nexport interface StepStartedEvent extends AgentMessageChunk {\n  event: \"step.started\";\n  data: {\n    stepId: string; // Unique identifier for this step\n    runId: string; // Which run this step belongs to\n    description?: string; // Human-readable description\n    metadata?: Record<string, unknown>;\n  };\n}\n\nexport interface StepCompletedEvent extends AgentMessageChunk {\n  event: \"step.completed\";\n  data: {\n    stepId: string;\n    runId: string;\n    result?: unknown; // Step result if applicable\n    duration?: number; // Execution time in milliseconds\n  };\n}\n\nexport interface StepFailedEvent extends AgentMessageChunk {\n  event: \"step.failed\";\n  data: {\n    stepId: string;\n    runId: string;\n    error: string;\n    recoverable: boolean;\n    retryAttempt?: number;\n  };\n}\n\n// =============================================================================\n// PART LIFECYCLE EVENTS\n// =============================================================================\n\nexport interface PartCreatedEvent extends AgentMessageChunk {\n  event: \"part.created\";\n  data: {\n    partId: string; // Unique identifier for this part\n    runId: string; // Which run this part belongs to\n    messageId: string; // Which message this part belongs to\n    type:\n      | \"text\"\n      | \"tool-call\"\n      | \"tool-output\"\n      | \"reasoning\"\n      | \"data\"\n      | \"file\"\n      | \"refusal\";\n    metadata?: {\n      toolName?: string; // For tool-call parts\n      dataType?: string; // For data parts\n      mimeType?: string; // For file parts\n      agentName?: string; // For tracking which agent created this part\n    };\n  };\n}\n\nexport interface PartCompletedEvent extends AgentMessageChunk {\n  event: \"part.completed\";\n  data: {\n    partId: string;\n    runId: string;\n    messageId: string; // Which message this part belongs to\n    type: string;\n    finalContent: unknown; // The complete, aggregated content of this part\n    metadata?: {\n      toolName?: string; // For tool-call/tool-output parts\n      dataType?: string; // For data parts\n      mimeType?: string; // For file parts\n      agentName?: string; // For tracking which agent created this part\n    };\n  };\n}\n\nexport interface PartFailedEvent extends AgentMessageChunk {\n  event: \"part.failed\";\n  data: {\n    partId: string;\n    runId: string;\n    messageId: string; // Which message this part belongs to\n    type: string;\n    error: string;\n    recoverable: boolean;\n  };\n}\n\n// =============================================================================\n// CONTENT DELTA EVENTS\n// =============================================================================\n\nexport interface TextDeltaEvent extends AgentMessageChunk {\n  event: \"text.delta\";\n  data: {\n    partId: string; // Which part this delta belongs to\n    messageId: string; // Which message this delta belongs to\n    delta: string; // The text chunk\n  };\n}\n\nexport interface ToolCallArgumentsDeltaEvent extends AgentMessageChunk {\n  event: \"tool_call.arguments.delta\";\n  data: {\n    partId: string;\n    messageId: string; // Which message this delta belongs to\n    delta: string; // JSON string chunk\n    toolName?: string; // Included on first delta\n  };\n}\n\nexport interface ToolCallOutputDeltaEvent extends AgentMessageChunk {\n  event: \"tool_call.output.delta\";\n  data: {\n    partId: string;\n    messageId: string; // Which message this delta belongs to\n    delta: string; // Incremental tool output\n  };\n}\n\nexport interface ReasoningDeltaEvent extends AgentMessageChunk {\n  event: \"reasoning.delta\";\n  data: {\n    partId: string; // Which part this delta belongs to\n    messageId: string; // Which message this delta belongs to\n    delta: string; // The reasoning/thinking content chunk\n  };\n}\n\nexport interface DataDeltaEvent extends AgentMessageChunk {\n  event: \"data.delta\";\n  data: {\n    partId: string;\n    messageId: string; // Which message this delta belongs to\n    delta: unknown; // Incremental structured data\n  };\n}\n\n// =============================================================================\n// HUMAN-IN-THE-LOOP (HITL) EVENTS\n// =============================================================================\n\nexport interface HitlRequestedEvent extends AgentMessageChunk {\n  event: \"hitl.requested\";\n  data: {\n    requestId: string;\n    runId: string; // Which run is requesting approval\n    toolCalls: Array<{\n      partId: string; // The tool-call part that needs approval\n      toolName: string;\n      toolInput: unknown;\n    }>;\n    expiresAt: string; // ISO timestamp\n    metadata?: {\n      reason?: string; // Why approval is needed\n      riskLevel?: \"low\" | \"medium\" | \"high\";\n    };\n  };\n}\n\nexport interface HitlResolvedEvent extends AgentMessageChunk {\n  event: \"hitl.resolved\";\n  data: {\n    requestId: string;\n    runId: string;\n    resolution: \"approved\" | \"denied\" | \"partial\";\n    approvedTools?: string[]; // For partial approval\n    reason?: string;\n    resolvedBy: string; // User ID who resolved\n    resolvedAt: string; // ISO timestamp\n  };\n}\n\n// =============================================================================\n// METADATA AND CONTROL EVENTS\n// =============================================================================\n\nexport interface UsageUpdatedEvent extends AgentMessageChunk {\n  event: \"usage.updated\";\n  data: {\n    runId: string;\n    usage: {\n      promptTokens: number;\n      completionTokens: number;\n      totalTokens: number;\n      thinkingTokens?: number;\n    };\n    cumulative: boolean; // Whether this is cumulative or delta\n  };\n}\n\nexport interface MetadataUpdatedEvent extends AgentMessageChunk {\n  event: \"metadata.updated\";\n  data: {\n    runId: string;\n    metadata: Record<string, unknown>;\n    type: \"model_switch\" | \"parameter_change\" | \"context_update\" | \"other\";\n  };\n}\n\nexport interface StreamEndedEvent extends AgentMessageChunk {\n  event: \"stream.ended\";\n  data: {\n    scope: \"network\" | \"agent\";\n    messageId?: string; // Optional message context\n  };\n}\n\n// Legacy/generic error event for backward compatibility\nexport interface GenericErrorEvent extends AgentMessageChunk {\n  event: \"error\";\n  data: {\n    error: string;\n    agentId?: string;\n    recoverable?: boolean;\n    messageId?: string;\n  };\n}\n\n// =============================================================================\n// SEQUENCE COUNTER FOR SHARED STREAMING CONTEXTS\n// =============================================================================\n\n/**\n * A simple sequence counter that can be shared between streaming contexts\n * to ensure events are numbered correctly across related contexts\n */\nclass SequenceCounter {\n  private value: number = 0;\n\n  getNext(): number {\n    return this.value++;\n  }\n\n  current(): number {\n    return this.value;\n  }\n}\n\n// =============================================================================\n// STREAMING CONFIGURATION AND CONTEXT\n// =============================================================================\n\n/**\n * Public-facing streaming configuration interface\n */\nexport interface StreamingConfig {\n  /** Function to publish events to the client */\n  publish: (chunk: AgentMessageChunk) => Promise<void>;\n  /** When true, emit simulated chunked deltas; otherwise emit a single delta */\n  simulateChunking?: boolean;\n}\n\n/**\n * Internal streaming context that manages state and sequence numbers\n */\nexport class StreamingContext {\n  private publish: (chunk: AgentMessageChunk) => Promise<void>;\n  private sequenceCounter: SequenceCounter;\n  private debug: boolean;\n  private simulateChunking: boolean;\n\n  public readonly runId: string;\n  public readonly parentRunId?: string;\n  public readonly messageId: string;\n  public readonly threadId?: string;\n  public readonly userId?: string;\n  public readonly scope: \"network\" | \"agent\";\n\n  constructor(config: {\n    publish: (chunk: AgentMessageChunk) => Promise<void>;\n    runId: string;\n    parentRunId?: string;\n    messageId: string;\n    threadId?: string;\n    userId?: string;\n    scope: \"network\" | \"agent\";\n    sequenceCounter?: SequenceCounter;\n    debug?: boolean;\n    simulateChunking?: boolean;\n  }) {\n    this.publish = config.publish;\n    this.runId = config.runId;\n    this.parentRunId = config.parentRunId;\n    this.messageId = config.messageId;\n    this.threadId = config.threadId;\n    this.userId = config.userId;\n    this.scope = config.scope;\n    this.sequenceCounter = config.sequenceCounter || new SequenceCounter();\n    this.debug = config.debug ?? process.env.NODE_ENV === \"development\";\n    this.simulateChunking = config.simulateChunking ?? false;\n  }\n\n  /**\n   * Create a child streaming context for agent runs within network runs\n   */\n  createChildContext(agentRunId: string): StreamingContext {\n    return new StreamingContext({\n      publish: this.publish,\n      runId: agentRunId,\n      parentRunId: this.runId,\n      messageId: this.messageId,\n      threadId: this.threadId,\n      userId: this.userId,\n      scope: \"agent\",\n      sequenceCounter: this.sequenceCounter, // Share the same counter\n      debug: this.debug, // Inherit debug setting\n      simulateChunking: this.simulateChunking,\n    });\n  }\n\n  /**\n   * Create a context with different messageId but shared sequence counter\n   */\n  createContextWithSharedSequence(config: {\n    runId: string;\n    messageId: string;\n    scope: \"network\" | \"agent\";\n  }): StreamingContext {\n    return new StreamingContext({\n      publish: this.publish,\n      runId: config.runId,\n      parentRunId: this.runId,\n      messageId: config.messageId,\n      threadId: this.threadId,\n      userId: this.userId,\n      scope: config.scope,\n      sequenceCounter: this.sequenceCounter, // Share the same counter instance\n      debug: this.debug, // Inherit debug setting\n      simulateChunking: this.simulateChunking,\n    });\n  }\n\n  /**\n   * Extract context information from network state\n   */\n  static fromNetworkState(\n    networkState: State<StateData>,\n    config: {\n      publish: (chunk: AgentMessageChunk) => Promise<void>;\n      runId: string;\n      messageId: string;\n      scope: \"network\" | \"agent\";\n      debug?: boolean;\n      simulateChunking?: boolean;\n    }\n  ): StreamingContext {\n    const debug = config.debug ?? process.env.NODE_ENV === \"development\";\n    return new StreamingContext({\n      publish: config.publish,\n      runId: config.runId,\n      messageId: config.messageId,\n      threadId: networkState.threadId,\n      userId:\n        typeof (networkState.data as { userId?: unknown }).userId === \"string\"\n          ? ((networkState.data as { userId?: unknown }).userId as string)\n          : undefined,\n      scope: config.scope,\n      debug,\n      simulateChunking: config.simulateChunking ?? false,\n    });\n  }\n\n  /**\n   * Publish an event with automatic sequence numbering.\n   * Provides a stepId in the chunk for optional Inngest step wrapping by the developer.\n   */\n  async publishEvent(\n    event: Omit<AgentMessageChunk, \"timestamp\" | \"sequenceNumber\" | \"id\">\n  ): Promise<void> {\n    // Get the next sequence number from the shared counter\n    const sequenceNumber = this.sequenceCounter.getNext();\n\n    // Generate step ID with the sequence number\n    const stepId = this.generateStreamingStepId(event, sequenceNumber);\n\n    // Automatically enrich event data with threadId and userId if they exist\n    const enrichedData: Record<string, unknown> = { ...event.data };\n    if (this.threadId) {\n      enrichedData[\"threadId\"] = this.threadId;\n    }\n    if (this.userId) {\n      enrichedData[\"userId\"] = this.userId;\n    }\n\n    const chunk: AgentMessageChunk = {\n      ...event,\n      data: enrichedData,\n      timestamp: Date.now(),\n      sequenceNumber,\n      id: stepId,\n    };\n\n    try {\n      await this.publish(chunk);\n    } catch (err) {\n      // Swallow publishing errors to avoid breaking execution; best-effort streaming\n\n      console.warn(\n        \"[Streaming] Failed to publish event; continuing execution\",\n        {\n          error: err instanceof Error ? err.message : String(err),\n          event: chunk.event,\n          sequenceNumber: chunk.sequenceNumber,\n        }\n      );\n    }\n  }\n\n  /**\n   * Generate intelligent step IDs for streaming events\n   */\n  private generateStreamingStepId(\n    event: Omit<AgentMessageChunk, \"timestamp\" | \"sequenceNumber\" | \"id\">,\n    sequenceNumber: number\n  ): string {\n    return `publish-${sequenceNumber}:${event.event}`;\n  }\n\n  /**\n   * Generate a unique part ID for this streaming context\n   * OpenAI requires tool call IDs to be  40 characters\n   */\n  generatePartId(): string {\n    // Create shorter, OpenAI-compatible ID ( 40 chars)\n    // Format: \"tool_\" + shortened messageId + timestamp suffix + random\n    const shortMessageId = this.messageId.replace(/-/g, \"\").substring(0, 8); // 8 chars\n    const shortTimestamp = Date.now().toString().slice(-8); // Last 8 digits\n    const randomSuffix = Math.random().toString(36).substr(2, 6); // 6 chars\n\n    // Format: \"tool_\" (5) + shortMessageId (8) + \"_\" (1) + shortTimestamp (8) + \"_\" (1) + randomSuffix (6) = 29 chars\n    const partId = `tool_${shortMessageId}_${shortTimestamp}_${randomSuffix}`;\n    return partId;\n  }\n\n  /**\n   * Generate a unique step ID for this streaming context\n   */\n  generateStepId(baseName: string): string {\n    return `step_${baseName}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /** Returns whether simulated chunking is enabled for this context */\n  isSimulatedChunking(): boolean {\n    return this.simulateChunking;\n  }\n}\n\n/**\n * Union type of all possible streaming events\n */\nexport type StreamingEvent =\n  | RunStartedEvent\n  | RunCompletedEvent\n  | RunFailedEvent\n  | RunInterruptedEvent\n  | StepStartedEvent\n  | StepCompletedEvent\n  | StepFailedEvent\n  | PartCreatedEvent\n  | PartCompletedEvent\n  | PartFailedEvent\n  | TextDeltaEvent\n  | ToolCallArgumentsDeltaEvent\n  | ToolCallOutputDeltaEvent\n  | ReasoningDeltaEvent\n  | DataDeltaEvent\n  | HitlRequestedEvent\n  | HitlResolvedEvent\n  | UsageUpdatedEvent\n  | MetadataUpdatedEvent\n  | StreamEndedEvent\n  | GenericErrorEvent;\n\n/**\n * Type guard to check if an event is a specific type\n */\nexport function isEventType<T extends StreamingEvent>(\n  event: AgentMessageChunk,\n  eventType: T[\"event\"]\n): event is T {\n  return event.event === eventType;\n}\n\n/**\n * Utility to generate unique IDs\n */\nexport function generateId(): string {\n  const id = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  return id;\n}\n\n// =============================================================================\n// STEP WRAPPER FOR TRANSPARENT EVENT PUBLISHING (Proxy-based)\n// =============================================================================\n\n/**\n * Helper function to create a StepWrapper if streaming context is available\n */\nexport function createStepWrapper(\n  originalStep: GetStepTools<Inngest.Any> | undefined,\n  context?: StreamingContext\n): GetStepTools<Inngest.Any> | undefined {\n  if (!context || !originalStep) {\n    return originalStep;\n  }\n\n  // Use a Proxy to dynamically wrap the step tools\n  return new Proxy(originalStep, {\n    get(target, prop, receiver) {\n      // If the property is one we want to wrap (e.g., 'run'), return our wrapped version.\n      if (prop === \"run\") {\n        return async <T>(stepId: string, fn: () => Promise<T>): Promise<T> => {\n          // Delegate to the original Inngest step.run while emitting streaming events\n          const originalRun = Reflect.get(\n            target,\n            \"run\",\n            receiver\n          ) as unknown as <R>(id: string, fn: () => Promise<R>) => Promise<R>;\n\n          // Do not publish streaming step events here to avoid nested step.* within Inngest steps\n          // Rely on the actual Inngest step.run for step visibility in the console\n          return originalRun(stepId, fn);\n        };\n      }\n\n      // For any other property, just reflect it from the original step object.\n      return Reflect.get(\n        target,\n        prop,\n        receiver\n      ) as unknown as GetStepTools<Inngest.Any>[keyof GetStepTools<Inngest.Any>];\n    },\n  });\n}\n","import { type NetworkRun } from \"./network\";\nimport { type State, type StateData } from \"./state\";\nimport { type AgentResult } from \"./types\";\nimport { type GetStepTools, type Inngest } from \"inngest\";\nimport { type MaybePromise, getStepTools } from \"./util\";\n\n/**\n * History configuration for managing conversation history in agents and networks.\n *\n * Provides hooks for creating threads, loading existing conversation history,\n * and persisting new results to storage. This enables persistent conversations\n * that can span multiple runs while maintaining context.\n *\n * @example\n * ```typescript\n * const history: HistoryConfig<MyStateType> = {\n *   createThread: async ({ state, input }) => {\n *     const threadId = await db.createThread(state.userId);\n *     return { threadId };\n *   },\n *   get: async ({ threadId }) => {\n *     return await db.getMessages(threadId);\n *   },\n *   appendResults: async ({ threadId, newResults, userMessage }) => {\n *     // Save user message first (if provided)\n *     if (userMessage) {\n *       await db.saveUserMessage(threadId, userMessage);\n *     }\n *     // Then save agent results\n *     await db.saveMessages(threadId, newResults);\n *   }\n * };\n * ```\n */\nexport interface HistoryConfig<T extends StateData> {\n  /**\n   * createThread is called to create a new conversation thread if no\n   * threadId is present in the state. It should return the new threadId.\n   *\n   * This hook is called during the initialization phase before any agents run,\n   * allowing you to create a new conversation thread in your database and\n   * return its identifier.\n   *\n   * @param ctx - Context containing state, input, and execution tools\n   * @returns Promise resolving to an object with the new threadId\n   */\n  createThread?: (\n    ctx: History.CreateThreadContext<T>\n  ) => MaybePromise<{ threadId: string }>;\n\n  /**\n   * get is called to load initial conversation history.\n   * If provided, any results passed to createState will be ignored in favor\n   * of the results returned by this function.\n   *\n   * This hook is called after thread initialization but before any agents run,\n   * allowing you to hydrate the conversation state with previous messages\n   * and context from your database.\n   *\n   * @param ctx - Context containing state, threadId, and execution tools\n   * @returns Promise resolving to an array of previous AgentResults\n   */\n  get?: (ctx: History.Context<T>) => Promise<AgentResult[]>;\n\n  /**\n   * appendUserMessage is called at the beginning of a run to persist the\n   * user's message immediately. This ensures user intent is captured even\n   * if the agent run fails, enabling a \"regenerate\" workflow.\n   *\n   * @param ctx - Context containing the user message with its canonical ID\n   * @returns Promise that resolves when the message is successfully saved\n   */\n  appendUserMessage?: (\n    ctx: History.Context<T> & {\n      userMessage: {\n        id: string; // The canonical, client-generated message ID\n        content: string;\n        role: \"user\";\n        timestamp: Date;\n      };\n    }\n  ) => Promise<void>;\n\n  /**\n   * appendResults is called to save new agent results to storage after a\n   * network or agent run completes. This receives only the new results that\n   * were generated during the current run.\n   *\n   * @param ctx - Context containing state, threadId, step, and new agent results\n   * @returns Promise that resolves when results are successfully saved\n   */\n  appendResults?: (\n    ctx: History.Context<T> & {\n      newResults: AgentResult[];\n    }\n  ) => Promise<void>;\n}\n\nexport namespace History {\n  /**\n   * Context provides access to the current state and execution context\n   * when history hooks are called.\n   *\n   * This context is passed to both `get` and `appendResults` hooks,\n   * providing all necessary information for loading and saving conversation data.\n   */\n  export type Context<T extends StateData> = {\n    /** The current state containing user data and conversation context */\n    state: State<T>;\n    /** The network run instance for accessing network-level information */\n    network: NetworkRun<T>;\n    /** Inngest step tools for durable execution (when running in Inngest context) */\n    step?: GetStepTools<Inngest.Any>;\n    /** The user's input for this conversation turn */\n    input: string;\n    /** The thread identifier for this conversation (available for get/appendResults hooks) */\n    threadId?: string;\n  };\n\n  /**\n   * CreateThreadContext provides access to the current state and execution context\n   * when the createThread hook is called. Note that threadId is not included since\n   * that's what we're creating, and network is optional since createThread can be\n   * called from both network and standalone agent contexts.\n   *\n   * This context is passed to the `createThread` hook when a new conversation\n   * thread needs to be created.\n   */\n  export type CreateThreadContext<T extends StateData> = {\n    /** The current state containing user data */\n    state: State<T>;\n    /** The user's input for this conversation turn */\n    input: string;\n    /** Inngest step tools for durable execution (when running in Inngest context) */\n    step?: GetStepTools<Inngest.Any>;\n    /** The network run instance (optional - may not be available in standalone agent context) */\n    network?: NetworkRun<T>;\n  };\n\n  /**\n   * Config is an alias for HistoryConfig for consistency with other namespaces\n   */\n  export type Config<T extends StateData> = HistoryConfig<T>;\n}\n\n/**\n * Base configuration for thread operation functions.\n *\n * Contains the common parameters needed by history utility functions\n * to perform thread operations like initialization, loading, and saving.\n */\nexport type ThreadOperationConfig<T extends StateData> = {\n  /** The current state containing conversation data and user context */\n  state: State<T>;\n  /** History configuration with hooks for thread operations */\n  history?: HistoryConfig<T>;\n  /** The user's input for this conversation turn */\n  input: string;\n  /** The network run instance (optional for standalone agent contexts) */\n  network?: NetworkRun<T>;\n};\n\n/**\n * Configuration for saveThreadToStorage function - extends base config with initialResultCount.\n *\n * The initialResultCount is used to determine which results are \"new\" and should be\n * persisted, versus which results were loaded from history and should not be duplicated.\n */\nexport type SaveThreadToStorageConfig<T extends StateData> =\n  ThreadOperationConfig<T> & {\n    /** The number of results that existed before this run started (used to identify new results) */\n    initialResultCount: number;\n  };\n\n/**\n * Handles thread initialization logic - creates new threads or auto-generates threadIds.\n *\n * This function is called at the beginning of agent/network runs to ensure a valid\n * thread context exists. It will:\n * 1. Create a new thread using the `createThread` hook if no threadId exists\n * 2. Auto-generate a threadId if `history.get` is configured but no threadId was provided\n * 3. Do nothing if a threadId already exists or no history configuration is provided\n *\n * @param config - Configuration containing state, history, input, and optional network\n * @returns Promise that resolves when thread initialization is complete\n *\n * @example\n * ```typescript\n * await initializeThread({\n *   state: myState,\n *   history: myHistoryConfig,\n *   input: userInput,\n *   network: networkRun\n * });\n * console.log(myState.threadId); // Now has a valid threadId\n * ```\n */\nexport async function initializeThread<T extends StateData>(\n  config: ThreadOperationConfig<T>\n): Promise<void> {\n  const { state, history, input, network } = config;\n  if (!history) return;\n\n  const step = await getStepTools();\n\n  // If a client provided a threadId, ensure it exists in storage by calling createThread.\n  // Adapters should upsert when a threadId already exists on state.\n  if (state.threadId && history.createThread) {\n    await history.createThread({\n      state,\n      network,\n      input,\n      step,\n    });\n    // Do not re-assign the threadId here. The state's threadId is the source of truth.\n    return;\n  }\n\n  if (!state.threadId && history.createThread) {\n    // Create a new thread using the provided createThread function\n    const { threadId } = await history.createThread({\n      state,\n      network,\n      input,\n      step,\n    });\n    state.threadId = threadId;\n  } else if (!state.threadId && history.get) {\n    // Auto-generate a threadId if history.get is configured but no threadId was provided\n    state.threadId = crypto.randomUUID();\n\n    // Create a thread record in the database to ensure it exists\n    // This prevents appendResults from failing when trying to save messages to a non-existent thread\n    if (history.createThread) {\n      await history.createThread({\n        state,\n        network,\n        input,\n        step,\n      });\n    }\n  }\n}\n\n/**\n * Loads conversation history from storage if conditions are met.\n *\n * This function retrieves previous conversation messages from storage and populates\n * the state with historical context. It will only load history if:\n * 1. A history.get hook is configured\n * 2. A threadId exists in the state\n * 3. The state doesn't already have results OR messages (to avoid overwriting client-provided data)\n *\n * When either results or messages are provided to createState, this enables client-authoritative\n * mode where the client maintains conversation state and sends it with each request.\n *\n * @param config - Configuration containing state, history, input, and optional network\n * @returns Promise that resolves when history loading is complete\n *\n * @example\n * ```typescript\n * await loadThreadFromStorage({\n *   state: myState,\n *   history: myHistoryConfig,\n *   input: userInput,\n *   network: networkRun\n * });\n * console.log(myState.results); // Now contains previous conversation messages\n * ```\n */\nexport async function loadThreadFromStorage<T extends StateData>(\n  config: ThreadOperationConfig<T>\n): Promise<void> {\n  const { state, history, input, network } = config;\n  if (\n    !history?.get ||\n    !state.threadId ||\n    state.results.length > 0 ||\n    state.messages.length > 0\n  ) {\n    return;\n  }\n\n  const step = await getStepTools();\n\n  const historyResults = await history.get({\n    state,\n    network: network!,\n    input,\n    step,\n    threadId: state.threadId,\n  });\n\n  // Replace any existing results with those from history\n  state.setResults(historyResults);\n}\n\n/**\n * Saves new conversation results to storage via history.appendResults.\n *\n * This function persists only the new AgentResults that were generated during\n * the current run, excluding any historical results that were loaded via `loadThreadFromStorage`.\n * This prevents duplication of messages in storage. Additionally, it passes the user's\n * input message to enable complete conversation history persistence.\n *\n * @param config - Configuration containing state, history, input, network, and initialResultCount\n * @returns Promise that resolves when results are successfully saved\n *\n * @example\n * ```typescript\n * const initialCount = state.results.length;\n * // ... run agents that add new results ...\n * await saveThreadToStorage({\n *   state: myState,\n *   history: myHistoryConfig,\n *   input: userInput,\n *   initialResultCount: initialCount,\n *   network: networkRun\n * });\n * ```\n */\nexport async function saveThreadToStorage<T extends StateData>(\n  config: SaveThreadToStorageConfig<T>\n): Promise<void> {\n  const { state, history, initialResultCount, network, input } = config;\n  if (!history?.appendResults) return;\n\n  const step = await getStepTools();\n  const newResults = state.getResultsFrom(initialResultCount);\n\n  await history.appendResults({\n    state,\n    network: network!,\n    step,\n    newResults,\n    input,\n    threadId: state.threadId,\n  });\n}\n"],"mappings":"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","names":["randomUUID","z","z","requestParser","_a","toolChoice","z","responseParser","e","requestParser","responseParser","z","requestParser","_model","z","toolChoice","responseParser","requestParser","responseParser","requestParser","responseParser","requestParser","responseParser","z","z","z","randomUUID","next","agent"]}